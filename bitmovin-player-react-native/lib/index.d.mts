import React$1 from 'react';
import { ViewStyle } from 'react-native';

/**
 * Configures the adaptation logic.
 */
interface AdaptationConfig {
    /**
     * The upper bitrate boundary in bits per second for approximate network bandwidth consumption of the played source.
     * Can be set to `undefined` for no limitation.
     */
    maxSelectableBitrate?: number;
    /**
     * The initial bandwidth estimate in bits per second the player uses to select the optimal media tracks before actual bandwidth data is available. Overriding this value should only be done in specific cases and will most of the time not result in better selection logic.
     *
     * @platform Android
     * @see https://cdn.bitmovin.com/player/android/3/docs/player-core/com.bitmovin.player.api.media/-adaptation-config/initial-bandwidth-estimate-override.html
     */
    initialBandwidthEstimateOverride?: number;
}

/**
 * Quartiles that can be reached during an ad playback.
 */
declare enum AdQuartile {
    /**
     * Fist ad quartile.
     */
    FIRST = "first",
    /**
     * Mid ad quartile.
     */
    MID_POINT = "mid_point",
    /**
     * Third ad quartile.
     */
    THIRD = "third"
}
/**
 * The possible types an `AdSource` can be.
 */
declare enum AdSourceType {
    /**
     * Google Interactive Media Ads.
     */
    IMA = "ima",
    /**
     * Unknown ad source type.
     */
    UNKNOWN = "unknown",
    /**
     * Progressive ad type.
     */
    PROGRESSIVE = "progressive"
}
/**
 * Represents an ad source which can be assigned to an `AdItem`. An `AdItem` can have multiple `AdSource`s
 * as waterfalling option.
 */
interface AdSource {
    /**
     * The ad tag / url to the ad manifest.
     */
    tag: string;
    /**
     * The `AdSourceType` of this `AdSource`.
     */
    type: AdSourceType;
}
/**
 * Represents an ad break which can be scheduled for playback.
 *
 * One single `AdItem` can have multiple `AdSource`s where all but the first act as fallback ad sources
 * if the first one fails to load. The start and end of an ad break are signaled via `AdBreakStartedEvent`
 * and `AdBreakFinishedEvent`.
 */
interface AdItem {
    /**
     * The playback position at which the ad break is scheduled to start. Default value is "pre".
     *
     * Possible values are:
     *  • "pre": pre-roll ad (for VoD and Live streaming)
     *  • "post": post-roll ad (for VoD streaming only)
     *  • fractional seconds: "10", "12.5" (mid-roll ad, for VoD and Live streaming)
     *  • percentage of the entire video duration: "25%", "50%" (mid-roll ad, for VoD streaming only)
     *  • timecode hh:mm:ss.mmm: "00:10:30.000", "01:00:00.000" (mid-roll ad, for VoD streaming only)
     */
    position?: string;
    /**
     * The `AdSource`s that make up this `AdItem`. The first ad source in this array is used as the main ad.
     * Subsequent ad sources act as a fallback, meaning that if the main ad source does not provide a
     * valid response, the subsequent ad sources will be utilized one after another.
     *
     * The fallback ad sources need to have the same `AdSourceType` as the main ad source.
     */
    sources: AdSource[];
    /**
     * The amount of seconds the ad manifest is loaded in advance
     * compared to when the ad break is scheduled for playback.
     *
     * Default value is 0.0
     *
     * @platform Android
     */
    preloadOffset?: number;
}
/**
 * Contains configuration values regarding the ads which should be played back by the player.
 */
interface AdvertisingConfig {
    /**
     * The ad items that are scheduled when a new playback session is started via `Player.load()`.
     */
    schedule: AdItem[];
}
/**
 * Contains the base configuration options for an ad.
 */
interface AdConfig {
    /**
     * Specifies how many seconds of the main video content should be replaced by ad break(s).
     */
    replaceContentDuration: number;
}
/**
 * Holds various additional ad data.
 */
interface AdData {
    /**
     * The average bitrate of the progressive media file as defined in the VAST response.
     */
    bitrate?: number;
    /**
     * The maximum bitrate of the streaming media file as defined in the VAST response.
     */
    maxBitrate?: number;
    /**
     * The MIME type of the media file or creative as defined in the VAST response.
     */
    mimeType?: string;
    /**
     * The minimum bitrate of the streaming media file as defined in the VAST response.
     */
    minBitrate?: number;
}
/**
 * Defines basic properties available for every ad type.
 */
interface Ad {
    /**
     * The url the user should be redirected to when clicking the ad.
     */
    clickThroughUrl?: string;
    /**
     * Holds various additional `AdData`.
     */
    data?: AdData;
    /**
     * The height of the ad.
     */
    height: number;
    /**
     * Identifier for the ad. This might be autogenerated.
     */
    id?: string;
    /**
     * Determines whether an ad is linear, i.e. playback of main content needs to be paused for the ad.
     */
    isLinear: boolean;
    /**
     * The corresponding media file url for the ad.
     */
    mediaFileUrl?: string;
    /**
     * The width of the ad.
     */
    width: number;
}
/**
 * Contains information about an ad break.
 */
interface AdBreak {
    /**
     * The ads scheduled for this `AdBreak`.
     */
    ads: Ad[];
    /**
     * The id of the corresponding `AdBreakConfig`. This will be auto-generated.
     */
    id: string;
    /**
     * The time in seconds in the media timeline the `AdBreak` is scheduled for.
     */
    scheduleTime: number;
}

/**
 * Object used to configure the build-in analytics collector.
 */
interface AnalyticsConfig {
    /**
     * The analytics license key
     */
    licenseKey: string;
    /**
     * Flag to enable Ad tracking (default: false).
     */
    adTrackingDisabled?: boolean;
    /**
     * Flag to use randomised userId not depending on device specific values (default: false).
     */
    randomizeUserId?: boolean;
    /**
     * Default metadata to be sent with events.
     * Fields of the `SourceMetadata` are prioritized over the default metadata.
     */
    defaultMetadata?: DefaultMetadata;
}
/**
 * DefaultMetadata that can be used to enrich the analytics data.
 * DefaultMetadata is not bound to a specific source and can be used to set fields for the lifecycle of the collector.
 * If fields are specified in `SourceMetadata` and `DefaultMetadata`, `SourceMetadata` takes precedence.
 */
interface DefaultMetadata extends CustomDataConfig {
    /**
     * CDN Provide that the video playback session is using.
     */
    cdnProvider?: string;
    /**
     * User ID of the customer.
     */
    customUserId?: string;
}
/**
 * `SourceMetadata` that can be used to enrich the analytics data.
 */
interface SourceMetadata extends CustomDataConfig {
    /**
     * ID of the video in the CMS system
     */
    videoId?: String;
    /**
     * Human readable title of the video asset currently playing
     */
    title?: String;
    /**
     * Breadcrumb path to show where in the app the user is
     */
    path?: String;
    /**
     * Flag to see if stream is live before stream metadata is available
     */
    isLive?: boolean;
    /**
     * CDN Provider that the video playback session is using
     */
    cdnProvider?: String;
}
/**
 * Free-form data that can be used to enrich the analytics data
 * If customData is specified in `SourceMetadata` and `DefaultMetadata`
 * data is merged on a field basis with `SourceMetadata` taking precedence.
 */
interface CustomDataConfig {
    /**
     * Optional free-form custom data
     */
    customData1?: string;
    /**
     * Optional free-form custom data
     */
    customData2?: string;
    /**
     * Optional free-form custom data
     */
    customData3?: string;
    /**
     * Optional free-form custom data
     */
    customData4?: string;
    /**
     * Optional free-form custom data
     */
    customData5?: string;
    /**
     * Optional free-form custom data
     */
    customData6?: string;
    /**
     * Optional free-form custom data
     */
    customData7?: string;
    /**
     * Optional free-form custom data
     */
    customData8?: string;
    /**
     * Optional free-form custom data
     */
    customData9?: string;
    /**
     * Optional free-form custom data
     */
    customData10?: string;
    /**
     * Optional free-form custom data
     */
    customData11?: string;
    /**
     * Optional free-form custom data
     */
    customData12?: string;
    /**
     * Optional free-form custom data
     */
    customData13?: string;
    /**
     * Optional free-form custom data
     */
    customData14?: string;
    /**
     * Optional free-form custom data
     */
    customData15?: string;
    /**
     * Optional free-form custom data
     */
    customData16?: string;
    /**
     * Optional free-form custom data
     */
    customData17?: string;
    /**
     * Optional free-form custom data
     */
    customData18?: string;
    /**
     * Optional free-form custom data
     */
    customData19?: string;
    /**
     * Optional free-form custom data
     */
    customData20?: string;
    /**
     * Optional free-form custom data
     */
    customData21?: string;
    /**
     * Optional free-form custom data
     */
    customData22?: string;
    /**
     * Optional free-form custom data
     */
    customData23?: string;
    /**
     * Optional free-form custom data
     */
    customData24?: string;
    /**
     * Optional free-form custom data
     */
    customData25?: string;
    /**
     * Optional free-form custom data
     */
    customData26?: string;
    /**
     * Optional free-form custom data
     */
    customData27?: string;
    /**
     * Optional free-form custom data
     */
    customData28?: string;
    /**
     * Optional free-form custom data
     */
    customData29?: string;
    /**
     * Optional free-form custom data
     */
    customData30?: string;
    /**
     * Experiment name needed for A/B testing.
     */
    experimentName?: string;
}

/**
 * Provides the means to control the analytics collected by a `Player`.
 * Use the `Player.analytics` property to access a `Player`'s `AnalyticsApi`.
 */
declare class AnalyticsApi {
    /**
     * The native player id that this analytics api is attached to.
     */
    playerId: string;
    constructor(playerId: string);
    /**
     * Sends a sample with the provided custom data.
     * Does not change the configured custom data of the collector or source.
     */
    sendCustomDataEvent: (customData: CustomDataConfig) => void;
    /**
     * Gets the current user id used by the bundled analytics instance.
     *
     * @returns The current user id.
     */
    getUserId: () => Promise<string>;
}

/**
 * An audio session category defines a set of audio behaviors.
 * Choose a category that most accurately describes the audio behavior you require.
 *
 * Note the `playback` category is required in order to properly enable picture in picture support.
 *
 * - `ambient`: The category for an app in which sound playback is nonprimary — that is, your app also works with the sound turned off.
 * - `multiRoute`: The category for routing distinct streams of audio data to different output devices at the same time.
 * - `playAndRecord`: The category for recording (input) and playback (output) of audio, such as for a Voice over Internet Protocol (VoIP) app.
 * - `playback`: The category for playing recorded music or other sounds that are central to the successful use of your app.
 * - `record`: The category for recording audio while also silencing playback audio.
 * - `soloAmbient`: The default audio session category.
 *
 * @platform iOS
 * @see https://developer.apple.com/documentation/avfaudio/avaudiosession/category
 */
type AudioSessionCategory = 'ambient' | 'multiRoute' | 'playAndRecord' | 'playback' | 'record' | 'soloAmbient';
/**
 * An object that communicates to the system how you intend to use audio in your app.
 *
 * @platform iOS
 * @see https://developer.apple.com/documentation/avfaudio/avaudiosession
 */
declare const AudioSession: {
    /**
     * Sets the audio session's category.
     *
     * @platform iOS
     * @see https://developer.apple.com/documentation/avfaudio/avaudiosession/1616583-setcategory
     */
    setCategory: (category: AudioSessionCategory) => Promise<void>;
};

/**
 * Supported subtitle/caption file formats.
 * @platform Android, iOS, tvOS
 */
declare enum SubtitleFormat {
    /**
     * Closed Captioning (CEA) subtitle format.
     * @platform Android, iOS, tvOS
     */
    CEA = "cea",
    /**
     * Timed Text Markup Language (TTML) subtitle format.
     * @platform Android, iOS, tvOS
     */
    TTML = "ttml",
    /**
     * Web Video Text Tracks Format (WebVTT) subtitle format.
     * @platform Android, iOS, tvOS
     */
    VTT = "vtt",
    /**
     * SubRip (SRT) subtitle format.
     * @platform Android, iOS, tvOS
     */
    SRT = "srt"
}
/**
 * Describes a subtitle track.
 * @platform Android, iOS, tvOS
 */
interface SubtitleTrack {
    /**
     * The URL to the timed file, e.g. WebVTT file.
     */
    url?: string;
    /**
     * The label for this track.
     */
    label?: string;
    /**
     * The unique identifier for this track. If no value is provided, a random UUIDv4 will be generated for it.
     */
    identifier?: string;
    /**
     * Specifies the file format to be used by this track.
     */
    format?: SubtitleFormat;
    /**
     * If set to true, this track would be considered as default. Default is `false`.
     */
    isDefault?: boolean;
    /**
     * Tells if a subtitle track is forced. If set to `true` it means that the player should automatically
     * select and switch this subtitle according to the selected audio language. Forced subtitles do
     * not appear in `Player.getAvailableSubtitles`.
     *
     * Default is `false`.
     */
    isForced?: boolean;
    /**
     * The IETF BCP 47 language tag associated with this track, e.g. `pt`, `en`, `es` etc.
     */
    language?: string;
}
/**
 * A subtitle track that can be added to `SourceConfig.subtitleTracks`.
 */
interface SideLoadedSubtitleTrack extends SubtitleTrack {
    url: string;
    label: string;
    language: string;
    format: SubtitleFormat;
}

/**
 * Quality definition of a video representation.
 */
interface VideoQuality {
    /**
     * The id of the media quality.
     */
    id: string;
    /**
     * The label of the media quality that should be exposed to the user.
     */
    label?: string;
    /**
     * The bitrate of the media quality.
     */
    bitrate?: number;
    /**
     * The codec of the media quality.
     */
    codec?: string;
    /**
     * The frame rate of the video quality. If the frame rate is not known or not applicable a value of -1 will be returned.
     */
    frameRate?: number;
    /**
     * The height of the video quality.
     */
    height?: number;
    /**
     * The width of the video quality.
     */
    width?: number;
}

/**
 * Represents an audio track for a video.
 */
interface AudioTrack {
    /**
     * The URL to the timed file, e.g. WebVTT file.
     */
    url?: string;
    /**
     * The label for this track.
     */
    label?: string;
    /**
     * The unique identifier for this track. If no value is provided, a random UUIDv4 will be generated for it.
     */
    identifier?: string;
    /**
     * If set to true, this track would be considered as default. Default is `false`.
     */
    isDefault?: boolean;
    /**
     * The IETF BCP 47 language tag associated with this track, e.g. `pt`, `en`, `es` etc.
     */
    language?: string;
}

interface NativeInstanceConfig {
    /**
     * Optionally user-defined string `id` for the native instance.
     * Used to access a certain native instance from any point in the source code then call
     * methods/properties on it.
     *
     * When left empty, a random `UUIDv4` is generated for it.
     * @example
     * Accessing or creating the `Player` with `nativeId` equal to `my-player`:
     * ```
     * const player = new Player({ nativeId: 'my-player' })
     * player.play(); // call methods and properties...
     * ```
     */
    nativeId?: string;
}
declare abstract class NativeInstance<Config extends NativeInstanceConfig> {
    /**
     * Optionally user-defined string `id` for the native instance, or UUIDv4.
     */
    readonly nativeId: string;
    /**
     * The configuration object used to initialize this instance.
     */
    readonly config?: Config;
    /**
     * Generate UUID in case the user-defined `nativeId` is empty.
     */
    constructor(config?: Config);
    /**
     * Flag indicating whether the native resources of this object have been created internally
     * .i.e `initialize` has been called.
     */
    abstract isInitialized: boolean;
    /**
     * Create the native object/resources that will be managed by this instance.
     */
    abstract initialize(): void;
    /**
     * Flag indicating whether the native resources of this object have been disposed .i.e
     * `destroy` has been called.
     */
    abstract isDestroyed: boolean;
    /**
     * Dispose the native object/resources created by this instance during `initialize`.
     */
    abstract destroy(): void;
}

/**
 * Represents a FairPlay Streaming DRM config.
 */
interface FairplayConfig {
    /**
     * The DRM license acquisition URL.
     */
    licenseUrl: string;
    /**
     * The URL to the FairPlay Streaming certificate of the license server.
     */
    certificateUrl?: string;
    /**
     * A dictionary to specify custom HTTP headers for the license request.
     */
    licenseRequestHeaders?: Record<string, string>;
    /**
     * A dictionary to specify custom HTTP headers for the certificate request.
     */
    certificateRequestHeaders?: Record<string, string>;
    /**
     * A block to prepare the loaded certificate before building SPC data and passing it into the
     * system. This is needed if the server responds with anything else than the certificate, e.g. if
     * the certificate is wrapped into a JSON object. The server response for the certificate request
     * is passed as parameter “as is”.
     *
     * Note that both the passed `certificate` data and this block return value should be a Base64
     * string. So use whatever solution suits you best to handle Base64 in React Native.
     *
     * @param certificate - Base64 encoded certificate data.
     * @returns The processed Base64 encoded certificate.
     */
    prepareCertificate?: (certificate: string) => string;
    /**
     * A block to prepare the data which is sent as the body of the POST license request.
     * As many DRM providers expect different, vendor-specific messages, this can be done using
     * this user-defined block.
     *
     * Note that both the passed `message` data and this block return value should be a Base64 string.
     * So use whatever solution suits you best to handle Base64 in React Native.
     *
     * @param message - Base64 encoded message data.
     * @param assetId - Stream asset ID.
     * @returns The processed Base64 encoded message.
     */
    prepareMessage?: (message: string, assetId: string) => string;
    /**
     * A block to prepare the data which is sent as the body of the POST request for syncing the DRM
     * license information.
     *
     * Note that both the passed `syncMessage` data and this block return value should be a Base64
     * string. So use whatever solution suits you best to handle Base64 in React Native.
     *
     * @param message - Base64 encoded message data.
     * @param assetId - Asset ID.
     * @returns The processed Base64 encoded sync message.
     */
    prepareSyncMessage?: (syncMessage: string, assetId: string) => string;
    /**
     * A block to prepare the loaded CKC Data before passing it to the system. This is needed if the
     * server responds with anything else than the license, e.g. if the license is wrapped into a JSON
     * object.
     *
     * Note that both the passed `license` data and this block return value should be a Base64 string.
     * So use whatever solution suits you best to handle Base64 in React Native.
     *
     * @param license - Base64 encoded license data.
     * @returns The processed Base64 encoded license.
     */
    prepareLicense?: (license: string) => string;
    /**
     * A block to prepare the URI (without the skd://) from the HLS manifest before passing it to the
     * system.
     *
     * @param licenseServerUrl - License server URL string.
     * @returns The processed license server URL string.
     */
    prepareLicenseServerUrl?: (licenseServerUrl: string) => string;
    /**
     * A block to prepare the `contentId`, which is sent to the FairPlay Streaming license server as
     * request body, and which is used to build the SPC data. As many DRM providers expect different,
     * vendor-specific messages, this can be done using this user-defined block. The parameter is the
     * skd:// URI extracted from the HLS manifest (m3u8) and the return value should be the contentID
     * as string.
     *
     * @param contentId - Extracted content id string.
     * @returns The processed contentId.
     */
    prepareContentId?: (contentId: string) => string;
}

/**
 * Represents a Widevine Streaming DRM config.
 * @platform Android, iOS (only for casting).
 */
interface WidevineConfig {
    /**
     * The DRM license acquisition URL.
     */
    licenseUrl: string;
    /**
     * A map containing the HTTP request headers, or null.
     */
    httpHeaders?: Record<string, string>;
    /**
     * A block to prepare the data which is sent as the body of the POST license request.
     * As many DRM providers expect different, vendor-specific messages, this can be done using
     * this user-defined block.
     *
     * Note that both the passed `message` data and this block return value should be a Base64 string.
     * So use whatever solution suits you best to handle Base64 in React Native.
     *
     * @platform Android
     *
     * @param message - Base64 encoded message data.
     * @returns The processed Base64 encoded message.
     */
    prepareMessage?: (message: string) => string;
    /**
     * A block to prepare the loaded CKC Data before passing it to the system. This is needed if the
     * server responds with anything else than the license, e.g. if the license is wrapped into a JSON
     * object.
     *
     * Note that both the passed `license` data and this block return value should be a Base64 string.
     * So use whatever solution suits you best to handle Base64 in React Native.
     *
     * @platform Android
     *
     * @param license - Base64 encoded license data.
     * @returns The processed Base64 encoded license.
     */
    prepareLicense?: (license: string) => string;
    /**
     * Set widevine's preferred security level.
     *
     * @platform Android
     */
    preferredSecurityLevel?: string;
    /**
     * Indicates if the DRM sessions should be kept alive after a source is unloaded.
     * This allows DRM sessions to be reused over several different source items with the same DRM configuration as well
     * as the same DRM scheme information.
     * Default: `false`
     *
     * @platform Android
     */
    shouldKeepDrmSessionsAlive?: boolean;
}

/**
 * Represents the general Streaming DRM config.
 */
interface DrmConfig extends NativeInstanceConfig {
    /**
     * FairPlay specific configuration.
     *
     * @platform iOS
     */
    fairplay?: FairplayConfig;
    /**
     * Widevine specific configuration.
     *
     * @platform Android, iOS (only for casting).
     */
    widevine?: WidevineConfig;
}
/**
 * Represents a native DRM configuration object.
 * @internal
 */
declare class Drm extends NativeInstance<DrmConfig> {
    /**
     * Whether this object's native instance has been created.
     */
    isInitialized: boolean;
    /**
     * Whether this object's native instance has been disposed.
     */
    isDestroyed: boolean;
    /**
     * Allocates the DRM config instance and its resources natively.
     */
    initialize: () => void;
    /**
     * Destroys the native DRM config and releases all of its allocated resources.
     */
    destroy: () => void;
    /**
     * iOS only.
     *
     * Applies the user-defined `prepareCertificate` function to native's `certificate` data and store
     * the result back in `DrmModule`.
     *
     * Called from native code when `FairplayConfig.prepareCertificate` is dispatched.
     *
     * @param certificate - Base64 encoded certificate data.
     */
    onPrepareCertificate: (certificate: string) => void;
    /**
     * Applies the user-defined `prepareMessage` function to native's `message` data and store
     * the result back in `DrmModule`.
     *
     * Called from native code when `prepareMessage` is dispatched.
     *
     * @param message - Base64 encoded message data.
     * @param assetId - Optional asset ID. Only sent by iOS.
     */
    onPrepareMessage: (message: string, assetId?: string) => void;
    /**
     * iOS only.
     *
     * Applies the user-defined `prepareSyncMessage` function to native's `syncMessage` data and
     * store the result back in `DrmModule`.
     *
     * Called from native code when `FairplayConfig.prepareSyncMessage` is dispatched.
     *
     * @param syncMessage - Base64 encoded sync SPC message data.
     */
    onPrepareSyncMessage: (syncMessage: string, assetId: string) => void;
    /**
     * Applies the user-defined `prepareLicense` function to native's `license` data and store
     * the result back in `DrmModule`.
     *
     * Called from native code when `prepareLicense` is dispatched.
     *
     * @param license - Base64 encoded license data.
     */
    onPrepareLicense: (license: string) => void;
    /**
     * iOS only.
     *
     * Applies the user-defined `prepareLicenseServerUrl` function to native's `licenseServerUrl` data
     * and store the result back in `DrmModule`.
     *
     * Called from native code when `FairplayConfig.prepareLicenseServerUrl` is dispatched.
     *
     * @param licenseServerUrl - The license server URL string.
     */
    onPrepareLicenseServerUrl: (licenseServerUrl: string) => void;
    /**
     * iOS only.
     *
     * Applies the user-defined `prepareContentId` function to native's `contentId` string
     * and store the result back in `DrmModule`.
     *
     * Called from native code when `FairplayConfig.prepareContentId` is dispatched.
     *
     * @param contentId - The extracted contentId string.
     */
    onPrepareContentId: (contentId: string) => void;
}

/**
 * Represents a VTT thumbnail.
 */
interface Thumbnail {
    /**
     * The start time of the thumbnail.
     */
    start: number;
    /**
     * The end time of the thumbnail.
     */
    end: number;
    /**
     * The raw cue data.
     */
    text: string;
    /**
     * The URL of the spritesheet
     */
    url: string;
    /**
     * The horizontal offset of the thumbnail in its spritesheet
     */
    x: number;
    /**
     * The vertical offset of the thumbnail in its spritesheet
     */
    y: number;
    /**
     * The width of the thumbnail
     */
    width: number;
    /**
     * The height of the thumbnail
     */
    height: number;
}

/**
 * Types of media that can be handled by the player.
 */
declare enum SourceType {
    /**
     * Indicates a missing source type.
     */
    NONE = "none",
    /**
     * Indicates media type HLS.
     */
    HLS = "hls",
    /**
     * Indicates media type DASH.
     */
    DASH = "dash",
    /**
     * Indicates media type Progressive MP4.
     */
    PROGRESSIVE = "progressive"
}
/**
 * The different loading states a {@link Source} instance can be in.
 */
declare enum LoadingState {
    /**
     * The source is unloaded.
     */
    UNLOADED = 0,
    /**
     * The source is currently loading.
     */
    LOADING = 1,
    /**
     * The source is loaded.
     */
    LOADED = 2
}
/**
 * Types of SourceOptions.
 */
interface SourceOptions {
    /**
     * The position where the stream should be started.
     * Number can be positive or negative depending on the used `TimelineReferencePoint`.
     * Invalid numbers will be corrected according to the stream boundaries.
     * For VOD this is applied at the time the stream is loaded, for LIVE when playback starts.
     */
    startOffset?: number;
    /**
     * Sets the Timeline reference point to calculate the startOffset from.
     * Default for live: `TimelineReferencePoint.END`.
     * Default for VOD: `TimelineReferencePoint.START`.
     */
    startOffsetTimelineReference?: TimelineReferencePoint;
}
/**
 Timeline reference point to calculate SourceOptions.startOffset from.
 Default for live: TimelineReferencePoint.EBD Default for VOD: TimelineReferencePoint.START.
 */
declare enum TimelineReferencePoint {
    /**
     * Relative offset will be calculated from the beginning of the stream or DVR window.
     */
    START = "start",
    /**
     * Relative offset will be calculated from the end of the stream or the live edge in case of a live stream with DVR window.
     */
    END = "end"
}
/**
 * Represents a source configuration that be loaded into a player instance.
 */
interface SourceConfig extends NativeInstanceConfig {
    /**
     *  The url for this source configuration.
     */
    url: string;
    /**
     * The `SourceType` for this configuration.
     */
    type?: SourceType;
    /**
     * The title of the video source.
     */
    title?: string;
    /**
     * The description of the video source.
     */
    description?: string;
    /**
     * The URL to a preview image displayed until the video starts.
     */
    poster?: string;
    /**
     * Indicates whether to show the poster image during playback.
     * Useful, for example, for audio-only streams.
     */
    isPosterPersistent?: boolean;
    /**
     * The DRM config for the source.
     */
    drmConfig?: DrmConfig;
    /**
     * External subtitle tracks to be added into the player.
     */
    subtitleTracks?: SideLoadedSubtitleTrack[];
    /**
     * External thumbnails to be added into the player.
     */
    thumbnailTrack?: string;
    /**
     * The optional custom metadata. Also sent to the cast receiver when loading the Source.
     */
    metadata?: Record<string, string>;
    /**
     * The `SourceOptions` for this configuration.
     */
    options?: SourceOptions;
    /**
     * The `SourceMetadata` for the {@link Source} to setup custom analytics tracking
     */
    analyticsSourceMetadata?: SourceMetadata;
}
/**
 * The remote control config for a source.
 * @platform iOS
 */
interface SourceRemoteControlConfig {
    /**
     * The `SourceConfig` for casting.
     * Enables to play different content when casting.
     * This can be useful when the remote playback device supports different streaming formats,
     * DRM systems, etc. than the local device.
     * If not set, the local source config will be used for casting.
     */
    castSourceConfig?: SourceConfig | null;
}
/**
 * Represents audio and video content that can be loaded into a player.
 */
declare class Source extends NativeInstance<SourceConfig> {
    /**
     * The native DRM config reference of this source.
     */
    private drm?;
    /**
     * The remote control config for this source.
     * This is only supported on iOS.
     *
     * @platform iOS
     */
    remoteControl: SourceRemoteControlConfig | null;
    /**
     * Whether the native {@link Source} object has been created.
     */
    isInitialized: boolean;
    /**
     * Whether the native {@link Source} object has been disposed.
     */
    isDestroyed: boolean;
    /**
     * Allocates the native {@link Source} instance and its resources natively.
     */
    initialize: () => void;
    /**
     * Destroys the native {@link Source} and releases all of its allocated resources.
     */
    destroy: () => void;
    /**
     * The duration of the source in seconds if it’s a VoD or `INFINITY` if it’s a live stream.
     * Default value is `0` if the duration is not available or not known.
     */
    duration: () => Promise<number>;
    /**
     * Whether the source is currently active in a player (i.e. playing back or paused).
     * Only one source can be active in the same player instance at any time.
     */
    isActive: () => Promise<boolean>;
    /**
     * Whether the source is currently attached to a player instance.
     */
    isAttachedToPlayer: () => Promise<boolean>;
    /**
     * Metadata for the currently loaded source.
     */
    metadata: () => Promise<Record<string, any> | null>;
    /**
     * Set metadata for the currently loaded source.
     * Setting the metadata to `null` clears the metadata object in native source.
     *
     * @param metadata metadata to be set.
     */
    setMetadata: (metadata: Record<string, any> | null) => void;
    /**
     * The current `LoadingState` of the source.
     */
    loadingState: () => Promise<LoadingState>;
    /**
     * @returns a `Thumbnail` for the specified playback time if available.
     * Supported thumbnail formats are:
     * - `WebVtt` configured via {@link SourceConfig.thumbnailTrack}, on all supported platforms
     * - HLS `Image Media Playlist` in the multivariant playlist, Android-only
     * - DASH `Image Adaptation Set` as specified in DASH-IF IOP, Android-only
     * If a `WebVtt` thumbnail track is provided, any potential in-manifest thumbnails are ignored on Android.
     *
     * @param time - The time in seconds for which to retrieve the thumbnail.
     */
    getThumbnail: (time: number) => Promise<Thumbnail | null>;
}

/**
 * Available HTTP request types.
 */
declare enum HttpRequestType {
    ManifestDash = "manifest/dash",
    ManifestHlsMaster = "manifest/hls/master",
    ManifestHlsVariant = "manifest/hls/variant",
    ManifestSmooth = "manifest/smooth",
    MediaProgressive = "media/progressive",
    MediaAudio = "media/audio",
    MediaVideo = "media/video",
    MediaSubtitles = "media/subtitles",
    MediaThumbnails = "media/thumbnails",
    DrmLicenseFairplay = "drm/license/fairplay",
    DrmCertificateFairplay = "drm/certificate/fairplay",
    DrmLicenseWidevine = "drm/license/widevine",
    KeyHlsAes = "key/hls/aes",
    Unknown = "unknown"
}
/**
 * Base64-encoded string representing the HTTP request body.
 */
type HttpRequestBody = string;
/** Represents an HTTP request. */
interface HttpRequest {
    /** The {@link HttpRequestBody} to send to the server. */
    body?: HttpRequestBody;
    /**
     * The HTTP Headers of the request.
     * Entries are expected to have the HTTP header as the key and its string content as the value.
     */
    headers: Record<string, string>;
    /** The HTTP method of the request. */
    method: string;
    /** The URL of the request. */
    url: string;
}
/**
 * Base64-encoded string representing the HTTP response body.
 */
type HttpResponseBody = string;
/** Represents an HTTP response. */
interface HttpResponse {
    /** The {@link HttpRequestBody} of the response. */
    body?: HttpResponseBody;
    /**
     * The HTTP Headers of the response.
     * Entries are expected to have the HTTP header as the key and its string content as the value.
     */
    headers: Record<string, string>;
    /** The corresponding request object of the response. */
    request: HttpRequest;
    /** The HTTP status code of the response. */
    status: number;
    /** The URL of the response. May differ from {@link HttpRequest.url} when redirects have happened. */
    url: string;
}
/**
 * The network API gives the ability to influence network requests.
 * It enables preprocessing requests and preprocessing responses.
 */
interface NetworkConfig extends NativeInstanceConfig {
    /**
     * Called before an HTTP request is made.
     * Can be used to change request parameters.
     *
     * @param type Type of the request to be made.
     * @param request The HTTP request to process.
     * @returns A Promise that resolves to an `HttpRequest` object.
     *          - If the promise resolves, the player will use the processed request.
     *          - If the promise rejects, the player will fall back to using the original request.
     *
     * @examples
     * ```
     *  const requestCallback = (type: HttpRequestType, request: HttpRequest) => {
     *    // Access current properties
     *
     *    console.log(JSON.stringify(type));
     *    console.log(JSON.stringify(request));
     *
     *    // Modify the request
     *
     *    request.headers['New-Header'] = 'val';
     *    request.method = 'GET';
     *
     *    // Return the processed request via a Promise
     *
     *    const processed: HttpRequest = {
     *      body: request.body,
     *      headers: request.headers,
     *      method: request.method,
     *      url: request.url,
     *    };
     *    return Promise.resolve(processed);
     *  };
     *
     *  const player = usePlayer({
     *    networkConfig: {
     *      preprocessHttpRequest: requestCallback,
     *    },
     *  });
     * ```
     */
    preprocessHttpRequest?: (type: HttpRequestType, request: HttpRequest) => Promise<HttpRequest>;
    /**
     * Called before an HTTP response is accessed by the player.
     * Can be used to access or change the response.
     *
     * @param type Type of the corresponding request object of the response.
     * @param response The HTTP response to process.
     * @returns A Promise that resolves to an `HttpResponse` object.
     *          - If the promise resolves, the player will use the processed response.
     *          - If the promise rejects, the player will fall back to using the original response.
     *
     * @example
     * ```
     *  const responseCallback = (type: HttpRequestType, response: HttpResponse) => {
     *    // Access response properties
     *
     *    console.log(JSON.stringify(type));
     *    console.log(JSON.stringify(response));
     *
     *    // Modify the response
     *
     *    response.headers['New-Header'] = 'val';
     *    response.url = response.request.url; // remove eventual redirect changes
     *
     *    // Return the processed response via a Promise
     *
     *    const processed: HttpResponse = {
     *      body: response.body,
     *      headers: response.headers,
     *      request: response.request,
     *      status: response.status,
     *      url: response.url,
     *    };
     *    return Promise.resolve(processed);
     *  };
     *
     *  // Properly attach the callback to the config
     *  const player = usePlayer({
     *    networkConfig: {
     *      preprocessHttpResponse: responseCallback,
     *    },
     *  });
     * ```
     */
    preprocessHttpResponse?: (type: HttpRequestType, response: HttpResponse) => Promise<HttpResponse>;
}

/**
 * Base event type for all events.
 */
interface Event {
    /**
     * This event name as it is on the native side.
     */
    name: string;
    /**
     * The UNIX timestamp in which this event happened.
     */
    timestamp: number;
}
/**
 * Base event type for error and warning events.
 */
interface ErrorEvent extends Event {
    /**
     * Error/Warning's code number.
     */
    code?: number;
    /**
     * Error/Warning's localized message.
     */
    message: string;
    /**
     * Underlying data emitted with the error or warning.
     */
    data?: Record<string, any>;
}
/**
 * Emitted when a source is loaded into the player.
 * Seeking and time shifting are allowed as soon as this event is seen.
 */
interface PlayerActiveEvent extends Event {
}
/**
 * Emitted when a player error occurred.
 */
interface PlayerErrorEvent extends ErrorEvent {
}
/**
 * Emitted when a player warning occurred.
 */
interface PlayerWarningEvent extends ErrorEvent {
}
/**
 * Emitted when the player is destroyed.
 */
interface DestroyEvent extends Event {
}
/**
 * Emitted when the player is muted.
 */
interface MutedEvent extends Event {
}
/**
 * Emitted when the player is unmuted.
 */
interface UnmutedEvent extends Event {
}
/**
 * Emitted when the player is ready for immediate playback, because initial audio/video
 * has been downloaded.
 */
interface ReadyEvent extends Event {
}
/**
 * Emitted when the player is paused.
 */
interface PausedEvent extends Event {
    /**
     * The player's playback time from when this event happened.
     */
    time: number;
}
/**
 * Emitted when the player received an intention to start/resume playback.
 */
interface PlayEvent extends Event {
    /**
     * The player's playback time from when this event happened.
     */
    time: number;
}
/**
 * Emitted when playback has started.
 */
interface PlayingEvent extends Event {
    /**
     * The player's playback time from when this event happened.
     */
    time: number;
}
/**
 * Emitted when the playback of the current media has finished.
 */
interface PlaybackFinishedEvent extends Event {
}
/**
 * Source object representation the way it appears on event's payloads such as `SeekEvent`, for example.
 *
 * This interface only type hints what should be the shape of a {@link Source} object inside an event's
 * payload during runtime so it has no direct relation with the `Source` class present in `src/source.ts`.
 *
 * Do not mistake it for a `NativeInstance` type.
 */
interface EventSource {
    /**
     * Event's source duration in seconds.
     */
    duration: number;
    /**
     * Whether this event's source is currently active in a player.
     */
    isActive: boolean;
    /**
     * Whether this event's source is currently attached to a player instance.
     */
    isAttachedToPlayer: boolean;
    /**
     * Metadata for this event's source.
     */
    metadata?: Record<string, any>;
    /**
     * The current {@link LoadingState} of the source.
     */
    loadingState: LoadingState;
}
/**
 * Represents a seeking position.
 */
interface SeekPosition {
    /**
     * The relevant {@link Source}.
     */
    source: EventSource;
    /**
     * The position within the {@link Source} in seconds.
     */
    time: number;
}
/**
 * Emitted when the player is about to seek to a new position.
 * This event only applies to VoD streams.
 * When looking for an equivalent for live streams, the {@link TimeShiftEvent} is relevant.
 */
interface SeekEvent extends Event {
    /**
     * Origin source metadata.
     */
    from: SeekPosition;
    /**
     * Target source metadata.
     */
    to: SeekPosition;
}
/**
 * Emitted when seeking has finished and data to continue playback is available.
 * This event only applies to VoD streams.
 * When looking for an equivalent for live streams, the {@link TimeShiftedEvent} is relevant.
 */
interface SeekedEvent extends Event {
}
/**
 * Emitted when the player starts time shifting.
 * This event only applies to live streams.
 * When looking for an equivalent for VoD streams, the {@link SeekEvent} is relevant.
 */
interface TimeShiftEvent extends Event {
    /**
     * The position from which we start the time shift
     */
    position: number;
    /**
     * The position to which we want to jump for the time shift
     */
    targetPosition: number;
}
/**
 * Emitted when time shifting has finished and data is available to continue playback.
 * This event only applies to live streams.
 * When looking for an equivalent for VoD streams, the {@link SeekedEvent} is relevant.
 */
interface TimeShiftedEvent extends Event {
}
/**
 * Emitted when the player begins to stall and to buffer due to an empty buffer.
 */
interface StallStartedEvent extends Event {
}
/**
 * Emitted when the player ends stalling, due to enough data in the buffer.
 */
interface StallEndedEvent extends Event {
}
/**
 * Emitted when the current playback time has changed.
 */
interface TimeChangedEvent extends Event {
    /**
     * The player's playback time from when this event happened.
     */
    currentTime: number;
}
/**
 * Emitted when a new source loading has started.
 */
interface SourceLoadEvent extends Event {
    /**
     * Source that is about to load.
     */
    source: EventSource;
}
/**
 * Emitted when a new source is loaded.
 * This does not mean that the source is immediately ready for playback.
 * {@link ReadyEvent} indicates the player is ready for immediate playback.
 */
interface SourceLoadedEvent extends Event {
    /**
     * Source that was loaded into player.
     */
    source: EventSource;
}
/**
 * Emitted when the current source has been unloaded.
 */
interface SourceUnloadedEvent extends Event {
    /**
     * Source that was unloaded from player.
     */
    source: EventSource;
}
/**
 * Emitted when a source error occurred.
 */
interface SourceErrorEvent extends ErrorEvent {
}
/**
 * Emitted when a source warning occurred.
 */
interface SourceWarningEvent extends ErrorEvent {
}
/**
 * Emitted when a new audio track is added to the player.
 */
interface AudioAddedEvent extends Event {
    /**
     * Audio track that has been added.
     */
    audioTrack: AudioTrack;
}
/**
 * Emitted when the player's selected audio track has changed.
 */
interface AudioChangedEvent extends Event {
    /**
     * Audio track that was previously selected.
     */
    oldAudioTrack: AudioTrack;
    /**
     * Audio track that is selected now.
     */
    newAudioTrack: AudioTrack;
}
/**
 * Emitted when an audio track is removed from the player.
 */
interface AudioRemovedEvent extends Event {
    /**
     * Audio track that has been removed.
     */
    audioTrack: AudioTrack;
}
/**
 * Emitted when a new subtitle track is added to the player.
 */
interface SubtitleAddedEvent extends Event {
    /**
     * Subtitle track that has been added.
     */
    subtitleTrack: SubtitleTrack;
}
/**
 * Emitted when a subtitle track is removed from the player.
 */
interface SubtitleRemovedEvent extends Event {
    /**
     * Subtitle track that has been removed.
     */
    subtitleTrack: SubtitleTrack;
}
/**
 * Emitted when the player's selected subtitle track has changed.
 */
interface SubtitleChangedEvent extends Event {
    /**
     * Subtitle track that was previously selected.
     */
    oldSubtitleTrack: SubtitleTrack;
    /**
     * Subtitle track that is selected now.
     */
    newSubtitleTrack: SubtitleTrack;
}
/**
 * Emitted when the player enters Picture in Picture mode.
 *
 * @platform iOS, Android
 */
interface PictureInPictureEnterEvent extends Event {
}
/**
 * Emitted when the player exits Picture in Picture mode.
 *
 * @platform iOS, Android
 */
interface PictureInPictureExitEvent extends Event {
}
/**
 * Emitted when the player has finished entering Picture in Picture mode on iOS.
 *
 * @platform iOS
 */
interface PictureInPictureEnteredEvent extends Event {
}
/**
 * Emitted when the player has finished exiting Picture in Picture mode on iOS.
 *
 * @platform iOS
 */
interface PictureInPictureExitedEvent extends Event {
}
/**
 * Emitted when the fullscreen functionality has been enabled.
 *
 * @platform iOS, Android
 */
interface FullscreenEnabledEvent extends Event {
}
/**
 * Emitted when the fullscreen functionality has been disabled.
 *
 * @platform iOS, Android
 */
interface FullscreenDisabledEvent extends Event {
}
/**
 * Emitted when the player enters fullscreen mode.
 *
 * @platform iOS, Android
 */
interface FullscreenEnterEvent extends Event {
}
/**
 * Emitted when the player exits fullscreen mode.
 *
 * @platform iOS, Android
 */
interface FullscreenExitEvent extends Event {
}
/**
 * Emitted when the availability of the Picture in Picture mode changed on Android.
 *
 * @platform Android
 */
interface PictureInPictureAvailabilityChangedEvent extends Event {
    /**
     * Whether Picture in Picture is available.
     */
    isPictureInPictureAvailable: boolean;
}
/**
 * Emitted when an ad break has started.
 */
interface AdBreakStartedEvent extends Event {
    /**
     * The {@link AdBreak} that has started.
     */
    adBreak?: AdBreak;
}
/**
 * Emitted when an ad break has finished.
 */
interface AdBreakFinishedEvent extends Event {
    /**
     * The {@link AdBreak} that has finished.
     */
    adBreak?: AdBreak;
}
/**
 * Emitted when the playback of an ad has started.
 */
interface AdStartedEvent extends Event {
    /**
     * The {@link Ad} this event is related to.
     */
    ad?: Ad;
    /**
     * The target URL to open once the user clicks on the ad.
     */
    clickThroughUrl?: string;
    /**
     * The {@link AdSourceType} of the started ad.
     */
    clientType?: AdSourceType;
    /**
     * The duration of the ad in seconds.
     */
    duration: number;
    /**
     * The index of the ad in the queue.
     */
    indexInQueue: number;
    /**
     * The position of the corresponding ad.
     */
    position?: string;
    /**
     * The skip offset of the ad in seconds.
     */
    skipOffset: number;
    /**
     * The main content time at which the ad is played.
     */
    timeOffset: number;
}
/**
 * Emitted when an ad has finished playback.
 */
interface AdFinishedEvent extends Event {
    /**
     * The {@link Ad} that finished playback.
     */
    ad?: Ad;
}
/**
 * Emitted when an error with the ad playback occurs.
 */
interface AdErrorEvent extends ErrorEvent {
    /**
     * The {@link AdConfig} for which the ad error occurred.
     */
    adConfig?: AdConfig;
    /**
     * The {@link AdItem} for which the ad error occurred.
     */
    adItem?: AdItem;
}
/**
 * Emitted when an ad was clicked.
 */
interface AdClickedEvent extends Event {
    /**
     * The click through url of the ad.
     */
    clickThroughUrl?: string;
}
/**
 * Emitted when an ad was skipped.
 */
interface AdSkippedEvent extends Event {
    /**
     * The ad that was skipped.
     */
    ad?: Ad;
}
/**
 * Emitted when the playback of an ad has progressed over a quartile boundary.
 */
interface AdQuartileEvent extends Event {
    /**
     * The {@link AdQuartile} boundary that playback has progressed over.
     */
    quartile: AdQuartile;
}
/**
 * Emitted when an ad manifest was successfully downloaded, parsed and added into the ad break schedule.
 */
interface AdScheduledEvent extends Event {
    /**
     * The total number of scheduled ads.
     */
    numberOfAds: number;
}
/**
 * Emitted when the download of an ad manifest is started.
 */
interface AdManifestLoadEvent extends Event {
    /**
     * The {@link AdBreak} this event is related to.
     */
    adBreak?: AdBreak;
    /**
     * The {@link AdConfig} of the loaded ad manifest.
     */
    adConfig?: AdConfig;
}
/**
 * Emitted when an ad manifest was successfully loaded.
 */
interface AdManifestLoadedEvent extends Event {
    /**
     * The {@link AdBreak} this event is related to.
     */
    adBreak?: AdBreak;
    /**
     * The {@link AdConfig} of the loaded ad manifest.
     */
    adConfig?: AdConfig;
    /**
     * How long it took for the ad tag to be downloaded in milliseconds.
     */
    downloadTime: number;
}
/**
 * Emitted when current video download quality has changed.
 */
interface VideoDownloadQualityChangedEvent extends Event {
    /**
     * The new quality
     */
    newVideoQuality: VideoQuality;
    /**
     * The previous quality
     */
    oldVideoQuality: VideoQuality;
}
/**
 * Emitted when the current video playback quality has changed.
 */
interface VideoPlaybackQualityChangedEvent extends Event {
    /**
     * The new quality
     */
    newVideoQuality: VideoQuality;
    /**
     * The previous quality
     */
    oldVideoQuality: VideoQuality;
}
/**
 * Emitted when casting to a cast-compatible device is available.
 */
interface CastAvailableEvent extends Event {
}
/**
 * Emitted when the playback on a cast-compatible device was paused.
 *
 * On Android {@link PausedEvent} is also emitted while casting.
 */
interface CastPausedEvent extends Event {
}
/**
 * Emitted when the playback on a cast-compatible device has finished.
 *
 * On Android {@link PlaybackFinishedEvent} is also emitted while casting.
 */
interface CastPlaybackFinishedEvent extends Event {
}
/**
 * Emitted when playback on a cast-compatible device has started.
 *
 * On Android {@link PlayingEvent} is also emitted while casting.
 */
interface CastPlayingEvent extends Event {
}
/**
 * Emitted when the cast app is launched successfully.
 */
interface CastStartedEvent extends Event {
    /**
     * The name of the cast device on which the app was launched.
     */
    deviceName: string | null;
}
/**
 * Emitted when casting is initiated, but the user still needs to choose which device should be used.
 */
interface CastStartEvent extends Event {
}
/**
 * Emitted when casting to a cast-compatible device is stopped.
 */
interface CastStoppedEvent extends Event {
}
/**
 * Emitted when the time update from the currently used cast-compatible device is received.
 */
interface CastTimeUpdatedEvent extends Event {
}
/**
 * Contains information for the {@link CastWaitingForDeviceEvent}.
 */
interface CastPayload {
    /**
     * The current time in seconds.
     */
    currentTime: number;
    /**
     * The name of the chosen cast device.
     */
    deviceName: string | null;
    /**
     * The type of the payload (always `"cast"`).
     */
    type: string;
}
/**
 * Emitted when a cast-compatible device has been chosen and the player is waiting for the device to get ready for
 * playback.
 */
interface CastWaitingForDeviceEvent extends Event {
    /**
     * The {@link CastPayload} object for the event
     */
    castPayload: CastPayload;
}
/**
 * Emitted when a download was finished.
 */
interface DownloadFinishedEvent extends Event {
    /**
     * The time needed to finish the request, in seconds.
     */
    downloadTime: number;
    /**
     * Which type of request this was.
     */
    requestType: HttpRequestType;
    /**
     * The HTTP status code of the request.
     * If opening the connection failed, a value of `0` is returned.
     */
    httpStatus: number;
    /**
     * If the download was successful.
     */
    isSuccess: boolean;
    /**
     * The last redirect location, or `null` if no redirect happened.
     */
    lastRedirectLocation?: String;
    /**
     * The size of the downloaded data, in bytes.
     */
    size: number;
    /**
     * The URL of the request.
     */
    url: String;
}
/**
 * Emitted when the player transitions from one playback speed to another.
 * @platform iOS, tvOS
 */
interface PlaybackSpeedChangedEvent extends Event {
    /**
     * The playback speed before the change happened.
     */
    from: number;
    /**
     * The playback speed after the change happened.
     */
    to: number;
}
/**
 * Emitted when a subtitle entry transitions into the active status.
 */
interface CueEnterEvent extends Event {
    /**
     * The playback time in seconds when the subtitle should be rendered.
     */
    start: number;
    /**
     * The playback time in seconds when the subtitle should be hidden.
     */
    end: number;
    /**
     * The textual content of this subtitle.
     */
    text?: string;
}
/**
 * Emitted when an active subtitle entry transitions into the inactive status.
 */
interface CueExitEvent extends Event {
    /**
     * The playback time in seconds when the subtitle should be rendered.
     */
    start: number;
    /**
     * The playback time in seconds when the subtitle should be hidden.
     */
    end: number;
    /**
     * The textual content of this subtitle.
     */
    text?: string;
}

/**
 * Type that defines all event props supported by `PlayerView` and `NativePlayerView`.
 * Used to generate the specific events interface for each component.
 */
interface EventProps {
    /**
     * Event emitted when an ad break has finished.
     */
    onAdBreakFinished: AdBreakFinishedEvent;
    /**
     * Event emitted when an ad break has started.
     */
    onAdBreakStarted: AdBreakStartedEvent;
    /**
     * Event emitted when an ad has been clicked.
     */
    onAdClicked: AdClickedEvent;
    /**
     * Event emitted when an ad error has occurred.
     */
    onAdError: AdErrorEvent;
    /**
     * Event emitted when an ad has finished.
     */
    onAdFinished: AdFinishedEvent;
    /**
     * Event emitted when an ad manifest starts loading.
     */
    onAdManifestLoad: AdManifestLoadEvent;
    /**
     * Event emitted when an ad manifest has been loaded.
     */
    onAdManifestLoaded: AdManifestLoadedEvent;
    /**
     * Event emitted when an ad quartile has been reached.
     */
    onAdQuartile: AdQuartileEvent;
    /**
     * Event emitted when an ad has been scheduled.
     */
    onAdScheduled: AdScheduledEvent;
    /**
     * Event emitted when an ad has been skipped.
     */
    onAdSkipped: AdSkippedEvent;
    /**
     * Event emitted when an ad has started.
     */
    onAdStarted: AdStartedEvent;
    /**
     * Event emitted when casting to a cast-compatible device is available.
     *
     * @platform iOS, Android
     */
    onCastAvailable: CastAvailableEvent;
    /**
     * Event emitted when the playback on a cast-compatible device was paused.
     *
     * @platform iOS, Android
     */
    onCastPaused: CastPausedEvent;
    /**
     * Event emitted when the playback on a cast-compatible device has finished.
     *
     * @platform iOS, Android
     */
    onCastPlaybackFinished: CastPlaybackFinishedEvent;
    /**
     * Event emitted when playback on a cast-compatible device has started.
     *
     * @platform iOS, Android
     */
    onCastPlaying: CastPlayingEvent;
    /**
     * Event emitted when the cast app is launched successfully.
     *
     * @platform iOS, Android
     */
    onCastStarted: CastStartedEvent;
    /**
     * Event emitted when casting is initiated, but the user still needs to choose which device should be used.
     *
     * @platform iOS, Android
     */
    onCastStart: CastStartEvent;
    /**
     * Event emitted when casting to a cast-compatible device is stopped.
     *
     * @platform iOS, Android
     */
    onCastStopped: CastStoppedEvent;
    /**
     * Event emitted when the time update from the currently used cast-compatible device is received.
     *
     * @platform iOS, Android
     */
    onCastTimeUpdated: CastTimeUpdatedEvent;
    /**
     * Event emitted when a cast-compatible device has been chosen and the player is waiting for the device to get ready for
     * playback.
     *
     * @platform iOS, Android
     */
    onCastWaitingForDevice: CastWaitingForDeviceEvent;
    /**
     * Event emitted when a subtitle entry transitions into the active status.
     */
    onCueEnter: CueEnterEvent;
    /**
     * Event emitted when an active subtitle entry transitions into the inactive status.
     */
    onCueExit: CueExitEvent;
    /**
     * Event emitted when the player is destroyed.
     */
    onDestroy: DestroyEvent;
    /**
     * Emitted when a download was finished.
     */
    onDownloadFinished: DownloadFinishedEvent;
    /**
     * All events emitted by the player.
     */
    onEvent: Event;
    /**
     * Event emitted when fullscreen mode has been enabled.
     *
     * @platform iOS, Android
     */
    onFullscreenEnabled: FullscreenEnabledEvent;
    /**
     * Event emitted when fullscreen mode has been disabled.
     *
     * @platform iOS, Android
     */
    onFullscreenDisabled: FullscreenDisabledEvent;
    /**
     * Event emitted when fullscreen mode has been entered.
     *
     * @platform iOS, Android
     */
    onFullscreenEnter: FullscreenEnterEvent;
    /**
     * Event emitted when fullscreen mode has been exited.
     *
     * @platform iOS, Android
     */
    onFullscreenExit: FullscreenExitEvent;
    /**
     * Event emitted when the player has been muted.
     */
    onMuted: MutedEvent;
    /**
     * Event emitted when the player has been paused.
     */
    onPaused: PausedEvent;
    /**
     * Event mitted when the availability of the Picture in Picture mode changed.
     */
    onPictureInPictureAvailabilityChanged: PictureInPictureAvailabilityChangedEvent;
    /**
     * Event emitted when the player enters Picture in Picture mode.
     */
    onPictureInPictureEnter: PictureInPictureEnterEvent;
    /**
     * Event emitted when the player entered Picture in Picture mode.
     *
     * @platform iOS
     */
    onPictureInPictureEntered: PictureInPictureEnteredEvent;
    /**
     * Event emitted when the player exits Picture in Picture mode.
     */
    onPictureInPictureExit: PictureInPictureExitEvent;
    /**
     * Event emitted when the player exited Picture in Picture mode.
     *
     * @platform iOS
     */
    onPictureInPictureExited: PictureInPictureExitedEvent;
    /**
     * Event emitted when the player received an intention to start/resume playback.
     */
    onPlay: PlayEvent;
    /**
     * Event emitted when the playback of the current media has finished.
     */
    onPlaybackFinished: PlaybackFinishedEvent;
    /**
     * Emitted when the player transitions from one playback speed to another.
     * @platform iOS, tvOS
     */
    onPlaybackSpeedChanged: PlaybackSpeedChangedEvent;
    /**
     * Event emitted when a source is loaded into the player.
     * Seeking and time shifting are allowed as soon as this event is seen.
     */
    onPlayerActive: PlayerActiveEvent;
    /**
     * Event Emitted when a player error occurred.
     */
    onPlayerError: PlayerErrorEvent;
    /**
     * Event emitted when a player warning occurred.
     */
    onPlayerWarning: PlayerWarningEvent;
    /**
     * Emitted when playback has started.
     */
    onPlaying: PlayingEvent;
    /**
     * Emitted when the player is ready for immediate playback, because initial audio/video
     * has been downloaded.
     */
    onReady: ReadyEvent;
    /**
     * Event emitted when the player is about to seek to a new position.
     * Only applies to VoD streams.
     */
    onSeek: SeekEvent;
    /**
     * Event emitted when seeking has finished and data to continue playback is available.
     * Only applies to VoD streams.
     */
    onSeeked: SeekedEvent;
    /**
     * Event mitted when the player starts time shifting.
     * Only applies to live streams.
     */
    onTimeShift: TimeShiftEvent;
    /**
     * Event emitted when time shifting has finished and data is available to continue playback.
     * Only applies to live streams.
     */
    onTimeShifted: TimeShiftedEvent;
    /**
     * Event emitted when the player begins to stall and to buffer due to an empty buffer.
     */
    onStallStarted: StallStartedEvent;
    /**
     * Event emitted when the player ends stalling, due to enough data in the buffer.
     */
    onStallEnded: StallEndedEvent;
    /**
     * Event emitted when a source error occurred.
     */
    onSourceError: SourceErrorEvent;
    /**
     * Event emitted when a new source loading has started.
     */
    onSourceLoad: SourceLoadEvent;
    /**
     * Event emitted when a new source is loaded.
     * This does not mean that the source is immediately ready for playback.
     * `ReadyEvent` indicates the player is ready for immediate playback.
     */
    onSourceLoaded: SourceLoadedEvent;
    /**
     * Event emitted when the current source has been unloaded.
     */
    onSourceUnloaded: SourceUnloadedEvent;
    /**
     * Event emitted when a source warning occurred.
     */
    onSourceWarning: SourceWarningEvent;
    /**
     * Event emitted when a new audio track is added to the player.
     */
    onAudioAdded: AudioAddedEvent;
    /**
     * Event emitted when the player's selected audio track has changed.
     */
    onAudioChanged: AudioChangedEvent;
    /**
     * Event emitted when an audio track is removed from the player.
     */
    onAudioRemoved: AudioRemovedEvent;
    /**
     * Event emitted when a new subtitle track is added to the player.
     */
    onSubtitleAdded: SubtitleAddedEvent;
    /**
     * Event emitted when the player's selected subtitle track has changed.
     */
    onSubtitleChanged: SubtitleChangedEvent;
    /**
     * Event emitted when a subtitle track is removed from the player.
     */
    onSubtitleRemoved: SubtitleRemovedEvent;
    /**
     * Event emitted when the current playback time has changed.
     */
    onTimeChanged: TimeChangedEvent;
    /**
     * Emitted when the player is unmuted.
     */
    onUnmuted: UnmutedEvent;
    /**
     * Emitted when current video download quality has changed.
     */
    onVideoDownloadQualityChanged: VideoDownloadQualityChangedEvent;
    /**
     * Emitted when the current video playback quality has changed.
     */
    onVideoPlaybackQualityChanged: VideoPlaybackQualityChangedEvent;
}
/**
 * Event props for `PlayerView`.
 *
 * Note the events of `PlayerView` are simply a proxy over
 * the events from `NativePlayerView` just removing RN's bubbling data.
 */
type PlayerViewEvents = {
    [Prop in keyof EventProps]?: (event: EventProps[Prop]) => void;
};

/**
 * Contains the state an OfflineContentManager can have.
 * @platform Android, iOS
 */
declare enum OfflineState {
    /**
     * The offline content is downloaded and ready for offline playback.
     */
    Downloaded = "Downloaded",
    /**
     * The offline content is currently downloading.
     */
    Downloading = "Downloading",
    /**
     * The download of the offline content is suspended, and is only partly downloaded yet.
     */
    Suspended = "Suspended",
    /**
     * The offline content is not downloaded. However, some data may be still cached.
     */
    NotDownloaded = "NotDownloaded"
}

/**
 * Represents the configuration to start a download.
 * @platform Android, iOS
 */
interface OfflineDownloadRequest {
    /**
     * Minimum video bitrate to download. The nearest higher available bitrate will be selected.
     */
    minimumBitrate?: number;
    /**
     * Audio tracks with IDs to download.
     */
    audioOptionIds?: string[];
    /**
     * Text tracks with IDs to download.
     */
    textOptionIds?: string[];
}

/**
 * Object used to configure a new `OfflineContentManager` instance.
 * @platform Android, iOS
 */
interface OfflineContentConfig extends NativeInstanceConfig {
    /**
     * An identifier for this source that is unique within the location and must never change.
     * The root folder will contain a folder based on this id.
     */
    identifier: string;
    /**
     * The `SourceConfig` used to download the offline resources.
     */
    sourceConfig: SourceConfig;
}

/**
 * Object used configure how the native offline managers create and get offline source configurations
 * @platform Android, iOS
 */
interface OfflineSourceOptions {
    /**
     * Whether or not the player should restrict playback only to audio, video and subtitle tracks which are stored offline on the device. This has to be set to true if the device has no network access.
     * @platform iOS
     */
    restrictedToAssetCache?: boolean;
}

/**
 * Superclass of entries which can be selected to download for offline playback
 * @platform Android, iOS
 */
interface OfflineContentOptionEntry {
    /**
     * The ID of the option.
     */
    id: string;
    /**
     * The language of the option.
     */
    language?: string;
}
/**
 * Represents the downloadable options provided via the `onOptionsAvailable` callback on `OfflineContentManagerListener`
 * @platform Android, iOS
 */
interface OfflineContentOptions {
    /**
     * Represents the audio options available for download
     */
    audioOptions: OfflineContentOptionEntry[];
    /**
     * Represents the text options available for download
     */
    textOptions: OfflineContentOptionEntry[];
}

/**
 * Enum to hold the `eventType` on the `BitmovinNativeOfflineEventData`
 * @platform Android, iOS
 */
declare enum OfflineEventType {
    onCompleted = "onCompleted",
    onError = "onError",
    onProgress = "onProgress",
    onOptionsAvailable = "onOptionsAvailable",
    onDrmLicenseUpdated = "onDrmLicenseUpdated",
    onDrmLicenseExpired = "onDrmLicenseExpired",
    onSuspended = "onSuspended",
    onResumed = "onResumed",
    onCanceled = "onCanceled"
}
/**
 * The base interface for all offline events.
 * @platform Android, iOS
 */
interface OfflineEvent<T extends OfflineEventType> {
    /**
     * The native id associated with the `OfflineContentManager` emitting this event
     */
    nativeId: string;
    /**
     * The supplied id representing the source associated with the `OfflineContentManager` emitting this event.
     */
    identifier: string;
    /**
     * The `OfflineEventType` that correlates to which native `OfflineContentManagerListener` method was called.
     */
    eventType: T;
    /**
     * The current offline download state
     */
    state: OfflineState;
}
/**
 * Emitted when the download process has completed.
 * @platform Android, iOS
 */
interface OnCompletedEvent extends OfflineEvent<OfflineEventType.onCompleted> {
    /**
     * The options that are available to download
     */
    options?: OfflineContentOptions;
}
/**
 * Emitted when an error has occurred.
 * @platform Android, iOS
 */
interface OnErrorEvent extends OfflineEvent<OfflineEventType.onError> {
    /**
     * The error code of the process error
     */
    code?: number;
    /**
     * The error message of the process error
     */
    message?: string;
}
/**
 * Emitted when there is a progress change for the process call.
 * @platform Android, iOS
 */
interface OnProgressEvent extends OfflineEvent<OfflineEventType.onProgress> {
    /**
     * The progress for the current process
     */
    progress: number;
}
/**
 * Emitted when the `OfflineContentOptions` is available after a `OfflineContentManager.getOptions` call.
 * @platform Android, iOS
 */
interface OnOptionsAvailableEvent extends OfflineEvent<OfflineEventType.onOptionsAvailable> {
    /**
     * The options that are available to download
     */
    options?: OfflineContentOptions;
}
/**
 * Emitted when the DRM license was updated.
 * @platform Android, iOS
 */
interface OnDrmLicenseUpdatedEvent extends OfflineEvent<OfflineEventType.onDrmLicenseUpdated> {
}
/**
 * Emitted when the DRM license has expired.
 * @platform iOS
 */
interface OnDrmLicenseExpiredEvent extends OfflineEvent<OfflineEventType.onDrmLicenseExpired> {
}
/**
 * Emitted when all active actions have been suspended.
 * @platform Android, iOS
 */
interface OnSuspendedEvent extends OfflineEvent<OfflineEventType.onSuspended> {
}
/**
 * Emitted when all actions have been resumed.
 * @platform Android, iOS
 */
interface OnResumedEvent extends OfflineEvent<OfflineEventType.onResumed> {
}
/**
 * Emitted when the download of the media content was canceled by the user and all partially downloaded content has been deleted from disk.
 * @platform Android, iOS
 */
interface OnCanceledEvent extends OfflineEvent<OfflineEventType.onCanceled> {
}
/**
 * The type aggregation for all possible native offline events received from the `DeviceEventEmitter`
 * @platform Android, iOS
 */
type BitmovinNativeOfflineEventData = OnCompletedEvent | OnOptionsAvailableEvent | OnProgressEvent | OnErrorEvent | OnDrmLicenseUpdatedEvent | OnDrmLicenseExpiredEvent | OnSuspendedEvent | OnResumedEvent | OnCanceledEvent;
/**
 * The listener that can be passed to the `OfflineContentManager` to receive callbacks for different events.
 * @platform Android, iOS
 */
interface OfflineContentManagerListener {
    /**
     * Emitted when the download process has completed.
     *
     * @param e The `OnCompletedEvent` that was emitted
     */
    onCompleted?: (e: OnCompletedEvent) => void;
    /**
     * Emitted when an error has occurred.
     *
     * @param e The `OnErrorEvent` that was emitted
     */
    onError?: (e: OnErrorEvent) => void;
    /**
     * Emitted when there is a progress change for the process call.
     *
     * @param e The `OnProgressEvent` that was emitted
     */
    onProgress?: (e: OnProgressEvent) => void;
    /**
     * Emitted when the `OfflineContentOptions` is available after a `OfflineContentManager.getOptions` call.
     *
     * @param e The `OnOptionsAvailableEvent` that was emitted
     */
    onOptionsAvailable?: (e: OnOptionsAvailableEvent) => void;
    /**
     * Emitted when the DRM license was updated.
     *
     * @param e The `OnDrmLicenseUpdatedEvent` that was emitted
     */
    onDrmLicenseUpdated?: (e: OnDrmLicenseUpdatedEvent) => void;
    /**
     * Emitted when the DRM license has expired.
     *
     * @param e The `OnDrmLicenseExpiredEvent` that was emitted
     */
    onDrmLicenseExpired?: (e: OnDrmLicenseExpiredEvent) => void;
    /**
     * Emitted when all active actions have been suspended.
     *
     * @param e The `OnSuspendedEvent` that was emitted
     */
    onSuspended?: (e: OnSuspendedEvent) => void;
    /**
     * Emitted when all actions have been resumed.
     *
     * @param e The `OnResumedEvent` that was emitted
     */
    onResumed?: (e: OnResumedEvent) => void;
    /**
     * Emitted when the download of the media content was canceled by the user and all partially downloaded content has been deleted from disk.
     *
     * @param e The `OnCanceledEvent` that was emitted
     */
    onCanceled?: (e: OnCanceledEvent) => void;
}

/**
 * Provides the means to download and store sources locally that can be played back with a Player
 * without an active network connection. An OfflineContentManager instance can be created via
 * the constructor and will be idle until initialized.
 *
 * @platform Android, iOS
 */
declare class OfflineContentManager extends NativeInstance<OfflineContentConfig> {
    isInitialized: boolean;
    isDestroyed: boolean;
    private eventSubscription?;
    private listeners;
    private drm?;
    constructor(config: OfflineContentConfig);
    /**
     * Allocates the native `OfflineManager` instance and its resources natively.
     * Registers the `DeviceEventEmitter` listener to receive data from the native `OfflineContentManagerListener` callbacks
     */
    initialize: () => Promise<void>;
    /**
     * Adds a listener to the receive data from the native `OfflineContentManagerListener` callbacks
     * Returns a function that removes this listener from the `OfflineContentManager` that registered it.
     */
    addListener: (listener: OfflineContentManagerListener) => (() => void);
    /**
     * Destroys the native `OfflineManager` and releases all of its allocated resources.
     */
    destroy: () => Promise<void>;
    /**
     * Gets the current state of the `OfflineContentManager`
     */
    state: () => Promise<OfflineState>;
    /**
     * Loads the current `OfflineContentOptions`.
     * When the options are loaded the data will be passed to the `OfflineContentManagerListener.onOptionsAvailable`.
     */
    getOptions: () => Promise<void>;
    /**
     * Enqueues downloads according to the `OfflineDownloadRequest`.
     * The promise will reject in the event of null or invalid request parameters.
     * The promise will reject when calling this method when download has already started or is completed.
     * The promise will resolve when the download has been queued. The download will is not finished when the promise resolves.
     */
    download: (request: OfflineDownloadRequest) => Promise<void>;
    /**
     * Resumes all suspended actions.
     */
    resume: () => Promise<void>;
    /**
     * Suspends all active actions.
     */
    suspend: () => Promise<void>;
    /**
     * Cancels and deletes the active download.
     */
    cancelDownload: () => Promise<void>;
    /**
     * Resolves how many bytes of storage are used by the offline content.
     */
    usedStorage: () => Promise<number>;
    /**
     * Deletes everything related to the related content ID.
     */
    deleteAll: () => Promise<void>;
    /**
     * Downloads the offline license.
     * When finished successfully, data will be passed to the `OfflineContentManagerListener.onDrmLicenseUpdated`.
     * Errors are transmitted to the `OfflineContentManagerListener.onError`.
     */
    downloadLicense: () => Promise<void>;
    /**
     * Releases the currently held offline license.
     * When finished successfully data will be passed to the `OfflineContentManagerListener.onDrmLicenseUpdated`.
     * Errors are transmitted to the `OfflineContentManagerListener.onError`.
     *
     * @platform Android
     */
    releaseLicense: () => Promise<void>;
    /**
     * Renews the already downloaded DRM license.
     * When finished successfully data will be passed to the `OfflineContentManagerListener.onDrmLicenseUpdated`.
     * Errors are transmitted to the `OfflineContentManagerListener.onError`.
     */
    renewOfflineLicense: () => Promise<void>;
}

/**
 * Contains config values which can be used to alter the visual presentation and behaviour of the player UI.
 */
interface StyleConfig {
    /**
     * Sets if the UI should be enabled or not. Default value is `true`.
     * @example
     * ```
     * const player = new Player({
     *   styleConfig: {
     *     isUiEnabled: false,
     *   },
     * });
     * ```
     */
    isUiEnabled?: boolean;
    /**
     * Sets which user interface type should be used.
     * Default value is `UserInterfaceType.bitmovin` on `iOS` and `UserInterfaceType.system` on `tvOS`.
     * This setting only applies if `StyleConfig.isUiEnabled` is set to true.
     * @example
     * ```
     * const player = new Player({
     *   styleConfig: {
     *     userInterfaceType: UserInterfaceType.System,
     *   },
     * });
     * ```
     * @platform iOS, tvOS
     */
    userInterfaceType?: UserInterfaceType;
    /**
     * Sets the CSS file that will be used for the UI. The default CSS file will be completely replaced by the CSS file set with this property.
     * @example
     * ```
     * const player = new Player({
     *   styleConfig: {
     *     playerUiCss: 'https://domain.tld/path/to/bitmovinplayer-ui.css',
     *   },
     * });
     * ```
     * @platform iOS, Android
     */
    playerUiCss?: string;
    /**
     * Sets a CSS file which contains supplemental styles for the player UI. These styles will be added to the default CSS file or the CSS file set with `StyleConfig.playerUiCss`.
     * @example
     * ```
     * const player = new Player({
     *   styleConfig: {
     *     supplementalPlayerUiCss: 'https://domain.tld/path/to/bitmovinplayer-supplemental-ui.css',
     *   },
     * });
     * ```
     * @platform iOS, Android
     */
    supplementalPlayerUiCss?: string;
    /**
     * Sets the JS file that will be used for the UI. The default JS file will be completely replaced by the JS file set with this property.
     * @example
     * ```
     * const player = new Player({
     *   styleConfig: {
     *     playerUiJs: 'https://domain.tld/path/to/bitmovinplayer-ui.js',
     *   },
     * });
     * ```
     * @platform iOS, Android
     */
    playerUiJs?: string;
    /**
     * Determines how the video content is scaled or stretched within the parent container’s bounds. Possible values are defined in `ScalingMode`.
     * Default value is `ScalingMode.fit`.
     * @example
     * ```
     * const player = new Player({
     *   styleConfig: {
     *     scalingMode: ScalingMode.Zoom,
     *   },
     * });
     * ```
     */
    scalingMode?: ScalingMode;
}
/**
 * Specifies how the video content is scaled or stretched.
 */
declare enum ScalingMode {
    /**
     * Specifies that the player should preserve the video’s aspect ratio and fit the video within the container's bounds.
     */
    Fit = "Fit",
    /**
     * Specifies that the video should be stretched to fill the container’s bounds. The aspect ratio may not be preserved.
     */
    Stretch = "Stretch",
    /**
     * Specifies that the player should preserve the video’s aspect ratio and fill the container’s bounds.
     */
    Zoom = "Zoom"
}
/**
 * Indicates which type of UI should be used.
 */
declare enum UserInterfaceType {
    /**
     * Indicates that Bitmovin's customizable UI should be used.
     */
    Bitmovin = "Bitmovin",
    /**
     * Indicates that the system UI should be used.
     * @platform iOS, tvOS
     */
    System = "System",
    /**
     * Indicates that only subtitles should be displayed along with the video content.
     */
    Subtitle = "Subtitle"
}

/**
 * This configuration is used as an incubator for experimental features. Tweaks are not officially
 * supported and are not guaranteed to be stable, i.e. their naming, functionality and API can
 * change at any time within the tweaks or when being promoted to an official feature and moved
 * into its final configuration namespace.
 */
interface TweaksConfig {
    /**
     * The frequency in seconds `onTimeChanged` is called with `TimeChangedEvent`s.
     *
     * Default value in iOS is `1.0`.
     * Default value in Android is `0.2`.
     *
     * @platform iOS, Android
     */
    timeChangedInterval?: number;
    /**
     * If enabled, HLS playlists will be parsed and additional features and events are enabled. This includes:
     *
     * - MetadataEvents carrying segment-specific metadata for custom HLS tags, like `#EXT-X-SCTE35`
     * - MetadataParsedEvents carrying segment-specific metadata for custom HLS tags, like `#EXT-X-SCTE35`
     * - DrmDataParsedEvents when a `#EXT-X-KEY` is found
     * - `Player.availableVideoQualities` includes additional information
     * - Automatic retries when HLS playlist requests failed with non-2xx HTTP status code
     *
     * Default is false.
     *
     * @platform iOS
     */
    isNativeHlsParsingEnabled?: boolean;
    /**
     * If enabled, playlists will be downloaded by the Bitmovin Player SDK instead of AVFoundation.
     * This enables additional features and events, like:
     *
     * - DownloadFinishedEvents for playlist downloads.
     * - SourceWarningEvents when no `#EXT-X-PLAYLIST-TYPE` is found If set to false, enabling
     * nativeHlsParsingEnabled won’t have any effect.
     *
     * Default is true.
     *
     * @platform iOS
     */
    isCustomHlsLoadingEnabled?: boolean;
    /**
     * The threshold which will be applied when seeking to the end in seconds. This value will be used
     * to calculate the maximum seekable time when calling `player.seek(time:)` or `player.playlist.seek(source:time:)`,
     * so the maximum value will be duration - seekToEndThreshold.
     *
     * This is useful if the duration of the segments does not match the duration specified in the
     * manifest. In this case, if we try to seek to the end, AVPlayer could get stuck and might stall
     * forever Therefore increasing this value could help.
     *
     * Default is 0.5.
     *
     * @platform iOS
     */
    seekToEndThreshold?: number;
    /**
     * Specifies the player behaviour when `Player.play` is called. Default is 'relaxed'.
     *
     * - 'relaxed': Starts playback when enough media data is buffered and continuous playback without stalling can be ensured. If insufficient media data is buffered for playback to start, the player will act as if the buffer became empty during playback.
     * - 'aggressive': When the buffer is not empty, this setting will cause the player to start playback of available media immediately. If insufficient media data is buffered for playback to start, the player will act as if the buffer became empty during playback.
     *
     * @platform iOS
     */
    playbackStartBehaviour?: 'relaxed' | 'aggressive';
    /**
     * Specifies the player behaviour when stalling should be exited. Default is 'relaxed'.
     *
     * - 'relaxed': The player will wait until the buffer is filled that it can, most likely, ensure continuous playback without another stalling right after playback continued.
     * - 'aggressive': The player will try to unstall as soon as some media data became available and will start playback of this media immediately.
     *
     * @platform iOS
     */
    unstallingBehaviour?: 'relaxed' | 'aggressive';
    /**
     * Constantly aggregated and weighted bandwidth samples are summed up to this weight limit to calculate an bandwidth estimation. Remaining samples (i.e. that would lead to exceeding the limit) are dropped from memory as they are not relevant anymore.
     * Default is 2000.
     *
     * @platform Android
     */
    bandwidthEstimateWeightLimit?: number;
    /**
     * Some devices have an incorrect implementation of MediaCodec.setOutputSurface. This leads to failure when the surface changes. To prevent failure, the codec will be released and re-instantiated in those scenarios.
     *
     * @platform Android
     */
    devicesThatRequireSurfaceWorkaround?: {
        /**
         * A device name as reported by Build.DEVICE.
         *
         * @see Build.DEVICE: https://developer.android.com/reference/kotlin/android/os/Build.html#DEVICE--
         */
        deviceNames?: string[];
        /**
         * A model name as reported by Build.MODEL.
         *
         * @see Build.MODEL: https://developer.android.com/reference/kotlin/android/os/Build.html#MODEL--
         */
        modelNames?: string[];
    };
    /**
     * Specifies if the language property on DASH Representations, HLS Renditions and SmoothStreaming QualityLevels is normalized.
     * If enabled, language properties are normalized to IETF BCP 47 language tags. Default is true.
     *
     * Examples:
     * - "ENG" is normalized to "en"
     * - "en_us" is normalized to "en-us"
     * - "en-US-x-lvariant-POSIX" is normalized to "en-us-posix"
     *
     * @platform Android
     */
    languagePropertyNormalization?: boolean;
    /**
     * The interval in which dynamic DASH windows are updated locally. I.e. The rate by which the
     * playback window is moved forward on the timeline.
     *
     * @platform Android
     */
    localDynamicDashWindowUpdateInterval?: number;
    /**
     * Specifies whether default positioning values should be assumed when parsing TTML regions in case of
     * unsupported TTML features. Default is true
     *
     * @platform Android
     */
    shouldApplyTtmlRegionWorkaround?: boolean;
    /**
     * Specifies whether a DRM session should be used for clear tracks of type video and audio. Using
     * DRM sessions for clear content avoids the recreation of decoders when transitioning between clear
     * and encrypted sections of content. Default is false.
     *
     * @platform Android
     */
    useDrmSessionForClearPeriods?: boolean;
    /**
     * Specifies whether a DRM session should be used for clear tracks of type video and audio in a clear
     * source that follows after a DRM protected source. In addition, a DRM session will be used for clear
     * periods in a DRM protected source. Using DRM sessions for clear content avoids the recreation of
     * decoders when transitioning between clear and encrypted sections of content. Default is false.
     *
     * @platform Android
     */
    useDrmSessionForClearSources?: boolean;
    /**
     * Specifies if the player should always fall back to an extractor matching the file type, if no
     * matching extractor was found. If the fallback is applied, this will ignore potential incompatibilities
     * with streams and thus can result in unstable or failing playback.
     *
     * @platform Android
     */
    useFiletypeExtractorFallbackForHls?: boolean;
    /**
     * Specifies whether the player should prefer software decoding over hardware decoding for ad playback.
     * This only affects ads playback, the player will still prefer hardware decoding for the main content.
     *
     * @platform Android
     */
    preferSoftwareDecodingForAds?: boolean;
    /**
     * Determines whether `AVKit` should update Now Playing information automatically when using System UI.
     *
     * - If set to `false`, the automatic updates of Now Playing Info sent by `AVKit` are disabled.
     *   This prevents interference with manual updates you may want to perform.
     * - If set to `true`, the default behaviour is maintained, allowing `AVKit` to handle Now Playing updates.
     *
     * Default is `true`.
     *
     * @platform iOS
     */
    updatesNowPlayingInfoCenter?: boolean;
}

/**
 * Configures remote playback behavior.
 */
interface RemoteControlConfig {
    /**
     * A URL to a CSS file the receiver app loads to style the receiver app.
     * Default value is `null`, indicating that the default CSS of the receiver app will be used.
     */
    receiverStylesheetUrl?: string | null;
    /**
     * A Map containing custom configuration values that are sent to the remote control receiver.
     * Default value is an empty map.
     */
    customReceiverConfig?: Record<string, string>;
    /**
     * Whether casting is enabled.
     * Default value is `true`.
     *
     * Has no effect if the `BitmovinCastManager` is not initialized before the `Player` is created with this configuration.
     */
    isCastEnabled?: boolean;
    /**
     * Indicates whether cookies and credentials will be sent along manifest requests on the cast receiver
     * Default value is `false`.
     */
    sendManifestRequestsWithCredentials?: boolean;
    /**
     * Indicates whether cookies and credentials will be sent along segment requests on the cast receiver
     * Default value is `false`.
     */
    sendSegmentRequestsWithCredentials?: boolean;
    /**
     * Indicates whether cookies and credentials will be sent along DRM licence requests on the cast receiver
     * Default value is `false`.
     */
    sendDrmLicenseRequestsWithCredentials?: boolean;
}

/**
 * Configures buffer target levels for different MediaTypes.
 */
interface BufferMediaTypeConfig {
    /**
     * The amount of data in seconds the player tries to buffer in advance.
     *
     * iOS and tvOS, only: If set to `0`, the player will choose an appropriate forward buffer duration suitable
     * for most use-cases.
     *
     * Default value is `0` on iOS and tvOS, `50` on Android
     */
    forwardDuration?: number;
}
/**
 * Player buffer config object to configure buffering behavior.
 */
interface BufferConfig {
    /**
     * Configures various settings for the audio and video buffer.
     */
    audioAndVideo?: BufferMediaTypeConfig;
    /**
     * Amount of seconds the player buffers before playback starts again after a stall. This value is
     * restricted to the maximum value of the buffer minus 0.5 seconds.
     *
     * Default is `5` seconds.
     *
     * @platform Android
     */
    restartThreshold?: number;
    /**
     * Amount of seconds the player buffers before playback starts. This value is restricted to the
     * maximum value of the buffer minus 0.5 seconds.
     *
     * Default is `2.5` seconds.
     *
     * @platform Android
     */
    startupThreshold?: number;
}

/**
 * Configures the playback behaviour of the player.
 */
interface PlaybackConfig {
    /**
     * Whether the player starts playing automatically after loading a source or not. Default is `false`.
     * @example
     * ```
     * const player = new Player({
     *   playbackConfig: {
     *     isAutoplayEnabled: true,
     *   },
     * });
     * ```
     */
    isAutoplayEnabled?: boolean;
    /**
     * Whether the sound is muted on startup or not. Default value is `false`.
     * @example
     * ```
     * const player = new Player({
     *   playbackConfig: {
     *     isMuted: true,
     *   },
     * });
     * ```
     */
    isMuted?: boolean;
    /**
     * Whether time shift / DVR for live streams is enabled or not. Default is `true`.
     *  @example
     * ```
     * const player = new Player({
     *   playbackConfig: {
     *     isTimeShiftEnabled: false,
     *   },
     * });
     * ```
     */
    isTimeShiftEnabled?: boolean;
    /**
     * Whether background playback is enabled or not.
     * Default is `false`.
     *
     * When set to `true`, playback is not automatically paused
     * anymore when the app moves to the background.
     * When set to `true`, also make sure to properly configure your app to allow
     * background playback.
     *
     * On tvOS, background playback is only supported for audio-only content.
     *
     * Default is `false`.
     *
     *  @example
     * ```
     * const player = new Player({
     *   {
     *     isBackgroundPlaybackEnabled: true,
     *   }
     * })
     * ```
     * @platform iOS, tvOS
     */
    isBackgroundPlaybackEnabled?: boolean;
    /**
     * Whether the Picture in Picture mode option is enabled or not. Default is `false`.
     *  @example
     * ```
     * const player = new Player({
     *   playbackConfig: {
     *     isPictureInPictureEnabled: true,
     *   },
     * });
     * ```
     * @deprecated Use {@link PictureInPictureConfig.isEnabled} instead.
     */
    isPictureInPictureEnabled?: boolean;
}

/**
 * Contains config values regarding the behaviour when playing live streams.
 */
interface LiveConfig {
    /**
     * The minimum buffer depth of a stream needed to enable time shifting.
     * When the internal value for the maximal possible timeshift is lower than this value,
     * timeshifting should be disabled. That means `Player.maxTimeShift` returns `0` in that case.
     * This value should always be non-positive value, default value is `-40`.
     */
    minTimeshiftBufferDepth?: number;
}

/**
 * Object used to configure a new `Player` instance.
 */
interface PlayerConfig extends NativeInstanceConfig {
    /**
     * Bitmovin license key that can be found in the Bitmovin portal.
     * If a license key is set here, it will be used instead of the license key found in the `Info.plist` and `AndroidManifest.xml`.
     * @example
     * Configuring the player license key from source code:
     * ```
     * const player = new Player({
     *   licenseKey: '\<LICENSE-KEY-CODE\>',
     * });
     * ```
     * @example
     * `licenseKey` can be safely omitted from source code if it has
     * been configured in Info.plist/AndroidManifest.xml.
     * ```
     * const player = new Player(); // omit `licenseKey`
     * player.play(); // call methods and properties...
     * ```
     */
    licenseKey?: string;
    /**
     * Configures playback behaviour. A default {@link PlaybackConfig} is set initially.
     */
    playbackConfig?: PlaybackConfig;
    /**
     * Configures the visual presentation and behaviour of the player UI. A default {@link StyleConfig} is set initially.
     */
    styleConfig?: StyleConfig;
    /**
     * Configures advertising functionality. A default {@link AdvertisingConfig} is set initially.
     */
    advertisingConfig?: AdvertisingConfig;
    /**
     * Configures experimental features. A default {@link TweaksConfig} is set initially.
     */
    tweaksConfig?: TweaksConfig;
    /**
     * Configures analytics functionality.
     */
    analyticsConfig?: AnalyticsConfig;
    /**
     * Configures adaptation logic.
     */
    adaptationConfig?: AdaptationConfig;
    /**
     * Configures remote playback functionality.
     */
    remoteControlConfig?: RemoteControlConfig;
    /**
     * Configures buffer settings. A default {@link BufferConfig} is set initially.
     */
    bufferConfig?: BufferConfig;
    /**
     * Configures behaviour when playing live content. A default {@link LiveConfig} is set initially.
     */
    liveConfig?: LiveConfig;
    /**
     * Configures network request manipulation functionality. A default {@link NetworkConfig} is set initially.
     */
    networkConfig?: NetworkConfig;
}

/**
 * Represents different types of media.
 */
declare enum MediaType {
    /**
     * Audio media type.
     */
    AUDIO = "audio",
    /**
     * Video media type.
     */
    VIDEO = "video"
}
/**
 * Represents different types of buffered data.
 */
declare enum BufferType {
    /**
     * Represents the buffered data starting at the current playback time.
     */
    FORWARD_DURATION = "forwardDuration",
    /**
     * Represents the buffered data up until the current playback time.
     */
    BACKWARD_DURATION = "backwardDuration"
}
/**
 * Holds different information about the buffer levels.
 */
interface BufferLevel {
    /**
     * The amount of currently buffered data, e.g. audio or video buffer level.
     */
    level?: number;
    /**
     * The target buffer level the player tries to maintain.
     */
    targetLevel?: number;
    /**
     * The media type the buffer data applies to.
     */
    media?: MediaType;
    /**
     * The buffer type the buffer data applies to.
     */
    type?: BufferType;
}
/**
 * Collection of {@link BufferLevel} objects
 */
interface BufferLevels {
    /**
     * {@link BufferLevel} for {@link MediaType.AUDIO}.
     */
    audio: BufferLevel;
    /**
     * {@link BufferLevel} for {@link MediaType.VIDEO}.
     */
    video: BufferLevel;
}
/**
 * Provides the means to configure buffer settings and to query the current buffer state.
 * Accessible through {@link Player.buffer}.
 */
declare class BufferApi {
    /**
     * The native player id that this buffer api is attached to.
     */
    readonly nativeId: string;
    constructor(playerId: string);
    /**
     * Gets the {@link BufferLevel|buffer level} from the Player
     * @param type The {@link BufferType} to return the level for.
     * @returns a {@link BufferLevels} that contains {@link BufferLevel} values for audio and video.
     */
    getLevel: (type: BufferType) => Promise<BufferLevels>;
    /**
     * Sets the target buffer level for the chosen buffer {@link BufferType} across all {@link MediaType} options.
     *
     * @param type The {@link BufferType} to set the target level for. On iOS and tvOS, only {@link BufferType.FORWARD_DURATION} is supported.
     * @param value The value to set. On iOS and tvOS when passing `0`, the player will choose an appropriate forward buffer duration suitable for most use-cases. On Android setting to `0` will have no effect.
     */
    setTargetLevel: (type: BufferType, value: number) => Promise<void>;
}

/**
 * Loads, controls and renders audio and video content represented through {@link Source}s. A player
 * instance can be created via the {@link usePlayer} hook and will idle until one or more {@link Source}s are
 * loaded. Once {@link Player.load} or {@link Player.loadSource} is called, the player becomes active and initiates necessary downloads to
 * start playback of the loaded source(s).
 *
 * Can be attached to {@link PlayerView} component in order to use Bitmovin's Player Web UI.
 * @see PlayerView
 */
declare class Player extends NativeInstance<PlayerConfig> {
    private network?;
    /**
     * Currently active source, or `null` if none is active.
     */
    source?: Source;
    /**
     * Whether the native `Player` object has been created.
     */
    isInitialized: boolean;
    /**
     * Whether the native `Player` object has been disposed.
     */
    isDestroyed: boolean;
    /**
     * The `AnalyticsApi` for interactions regarding the `Player`'s analytics.
     *
     * `undefined` if the player was created without analytics support.
     */
    analytics?: AnalyticsApi;
    /**
     * The {@link BufferApi} for interactions regarding the buffer.
     */
    buffer: BufferApi;
    /**
     * Allocates the native `Player` instance and its resources natively.
     */
    initialize: () => void;
    /**
     * Destroys the native `Player` and releases all of its allocated resources.
     */
    destroy: () => void;
    /**
     * Loads a new {@link Source} from `sourceConfig` into the player.
     */
    load: (sourceConfig: SourceConfig) => void;
    /**
     * Loads the downloaded content from {@link OfflineContentManager} into the player.
     */
    loadOfflineContent: (offlineContentManager: OfflineContentManager, options?: OfflineSourceOptions) => void;
    /**
     * Loads the given {@link Source} into the player.
     */
    loadSource: (source: Source) => void;
    /**
     * Unloads all {@link Source}s from the player.
     */
    unload: () => void;
    /**
     * Starts or resumes playback after being paused. Has no effect if the player is already playing.
     */
    play: () => void;
    /**
     * Pauses the video if it is playing. Has no effect if the player is already paused.
     */
    pause: () => void;
    /**
     * Seeks to the given playback time specified by the parameter `time` in seconds. Must not be
     * greater than the total duration of the video. Has no effect when watching a live stream since
     * seeking is not possible.
     *
     * @param time - The time to seek to in seconds.
     */
    seek: (time: number) => void;
    /**
     * Shifts the time to the given `offset` in seconds from the live edge. The resulting offset has to be within the
     * timeShift window as specified by `maxTimeShift` (which is a negative value) and 0. When the provided `offset` is
     * positive, it will be interpreted as a UNIX timestamp in seconds and converted to fit into the timeShift window.
     * When the provided `offset` is negative, but lower than `maxTimeShift`, then it will be clamped to `maxTimeShift`.
     * Has no effect for VoD.
     *
     * Has no effect if no sources are loaded.
     *
     * @param offset - Target offset from the live edge in seconds.
     */
    timeShift: (offset: number) => void;
    /**
     * Mutes the player if an audio track is available. Has no effect if the player is already muted.
     */
    mute: () => void;
    /**
     * Unmutes the player if it is muted. Has no effect if the player is already unmuted.
     */
    unmute: () => void;
    /**
     * Sets the player's volume between 0 (silent) and 100 (max volume).
     *
     * @param volume - The volume level to set.
     */
    setVolume: (volume: number) => void;
    /**
     * @returns The player's current volume level.
     */
    getVolume: () => Promise<number>;
    /**
     * @returns The current playback time in seconds.
     *
     * For VoD streams the returned time ranges between 0 and the duration of the asset.
     *
     * For live streams it can be specified if an absolute UNIX timestamp or a value
     * relative to the playback start should be returned.
     *
     * @param mode - The time mode to specify: an absolute UNIX timestamp ('absolute') or relative time ('relative').
     */
    getCurrentTime: (mode?: 'relative' | 'absolute') => Promise<number>;
    /**
     * @returns The total duration in seconds of the current video or INFINITY if it’s a live stream.
     */
    getDuration: () => Promise<number>;
    /**
     * @returns `true` if the player is muted.
     */
    isMuted: () => Promise<boolean>;
    /**
     * @returns `true` if the player is currently playing, i.e. has started and is not paused.
     */
    isPlaying: () => Promise<boolean>;
    /**
     * @returns `true` if the player has started playback but it's currently paused.
     */
    isPaused: () => Promise<boolean>;
    /**
     * @returns `true` if the displayed video is a live stream.
     */
    isLive: () => Promise<boolean>;
    /**
     * @remarks Only available for iOS devices.
     * @returns `true` when media is played externally using AirPlay.
     */
    isAirPlayActive: () => Promise<boolean>;
    /**
     * @remarks Only available for iOS devices.
     * @returns `true` when AirPlay is available.
     */
    isAirPlayAvailable: () => Promise<boolean>;
    /**
     * @returns The currently selected audio track or `null`.
     */
    getAudioTrack: () => Promise<AudioTrack | null>;
    /**
     * @returns An array containing {@link AudioTrack} objects for all available audio tracks.
     */
    getAvailableAudioTracks: () => Promise<AudioTrack[]>;
    /**
     * Sets the audio track to the ID specified by trackIdentifier. A list can be retrieved by calling getAvailableAudioTracks.
     *
     * @param trackIdentifier - The {@link AudioTrack.identifier} to be set.
     */
    setAudioTrack: (trackIdentifier: string) => Promise<void>;
    /**
     * @returns The currently selected {@link SubtitleTrack} or `null`.
     */
    getSubtitleTrack: () => Promise<SubtitleTrack | null>;
    /**
     * @returns An array containing SubtitleTrack objects for all available subtitle tracks.
     */
    getAvailableSubtitles: () => Promise<SubtitleTrack[]>;
    /**
     * Sets the subtitle track to the ID specified by trackIdentifier. A list can be retrieved by calling getAvailableSubtitles.
     *
     * @param trackIdentifier - The {@link SubtitleTrack.identifier} to be set.
     */
    setSubtitleTrack: (trackIdentifier?: string) => Promise<void>;
    /**
     * Dynamically schedules the {@link AdItem} for playback.
     * Has no effect if there is no active playback session.
     *
     * @param adItem - Ad to be scheduled for playback.
     *
     * @platform iOS, Android
     */
    scheduleAd: (adItem: AdItem) => void;
    /**
     * Skips the current ad.
     * Has no effect if the current ad is not skippable or if no ad is being played back.
     *
     * @platform iOS, Android
     */
    skipAd: () => void;
    /**
     * @returns `true` while an ad is being played back or when main content playback has been paused for ad playback.
     * @platform iOS, Android
     */
    isAd: () => Promise<boolean>;
    /**
     * The current time shift of the live stream in seconds. This value is always 0 if the active {@link Source} is not a
     * live stream or no sources are loaded.
     */
    getTimeShift: () => Promise<number>;
    /**
     * The limit in seconds for time shifting. This value is either negative or 0 and it is always 0 if the active
     * {@link Source} is not a live stream or no sources are loaded.
     */
    getMaxTimeShift: () => Promise<number>;
    /**
     * Sets the upper bitrate boundary for video qualities. All qualities with a bitrate
     * that is higher than this threshold will not be eligible for automatic quality selection.
     *
     * Can be set to `null` for no limitation.
     */
    setMaxSelectableBitrate: (bitrate: number | null) => void;
    /**
     * @returns a {@link Thumbnail} for the specified playback time for the currently active source if available.
     * Supported thumbnail formats are:
     * - `WebVtt` configured via {@link SourceConfig.thumbnailTrack}, on all supported platforms
     * - HLS `Image Media Playlist` in the multivariant playlist, Android-only
     * - DASH `Image Adaptation Set` as specified in DASH-IF IOP, Android-only
     * If a `WebVtt` thumbnail track is provided, any potential in-manifest thumbnails are ignored on Android.
     *
     * @param time - The time in seconds for which to retrieve the thumbnail.
     */
    getThumbnail: (time: number) => Promise<Thumbnail | null>;
    /**
     * Whether casting to a cast-compatible remote device is available. {@link CastAvailableEvent} signals when
     * casting becomes available.
     *
     * @platform iOS, Android
     */
    isCastAvailable: () => Promise<boolean>;
    /**
     * Whether video is currently being casted to a remote device and not played locally.
     *
     * @platform iOS, Android
     */
    isCasting: () => Promise<boolean>;
    /**
     * Initiates casting the current video to a cast-compatible remote device. The user has to choose to which device it
     * should be sent.
     *
     * @platform iOS, Android
     */
    castVideo: () => void;
    /**
     * Stops casting the current video. Has no effect if {@link Player.isCasting} is `false`.
     *
     * @platform iOS, Android
     */
    castStop: () => void;
    /**
     * Returns the currently selected video quality.
     * @returns The currently selected video quality.
     */
    getVideoQuality: () => Promise<VideoQuality>;
    /**
     * Returns an array containing all available video qualities the player can adapt between.
     * @returns An array containing all available video qualities the player can adapt between.
     */
    getAvailableVideoQualities: () => Promise<VideoQuality[]>;
    /**
     * Sets the video quality.
     * @remarks Only available on Android.
     * @platform Android
     *
     * @param qualityId value obtained from {@link VideoQuality}'s `id` property, which can be obtained via `Player.getAvailableVideoQualities()` to select a specific quality. To use automatic quality selection, 'auto' can be passed here.
     */
    setVideoQuality: (qualityId: String) => void;
    /**
     * Sets the playback speed of the player. Fast forward, slow motion and reverse playback are supported.
     * @note
     * - Slow motion is indicated by values between `0` and `1`.
     * - Fast forward by values greater than `1`.
     * - Slow reverse is used by values between `0` and `-1`, and fast reverse is used by values less than `-1`. iOS and tvOS only.
     * @note
     * Negative values are ignored during Casting and on Android.
     * @note
     * During reverse playback the playback will continue until the beginning of the active source is
     * reached. When reaching the beginning of the source, playback will be paused and the playback
     * speed will be reset to its default value of `1`. No {@link PlaybackFinishedEvent} will be
     * emitted in this case.
     *
     * @param playbackSpeed - The playback speed to set.
     */
    setPlaybackSpeed: (playbackSpeed: number) => void;
    /**
     * @see {@link setPlaybackSpeed} for details on which values playback speed can assume.
     * @returns The player's current playback speed.
     */
    getPlaybackSpeed: () => Promise<number>;
    /**
     * Checks the possibility to play the media at specified playback speed.
     * @param playbackSpeed - The playback speed to check.
     * @returns `true` if it's possible to play the media at the specified playback speed, otherwise `false`. On Android it always returns `undefined`.
     * @platform iOS, tvOS
     */
    canPlayAtPlaybackSpeed: (playbackSpeed: number) => Promise<boolean | undefined>;
}

/**
 * Handles the UI state change when fullscreen should be entered or exited.
 */
interface FullscreenHandler {
    /**
     * Indicates if the UI is currently in fullscreen mode
     */
    isFullscreenActive: boolean;
    /**
     * Is called by the `PlayerView` when the UI should enter fullscreen mode.
     */
    enterFullscreen(): void;
    /**
     * Is called by the `PlayerView` when the UI should exit fullscreen mode.
     */
    exitFullscreen(): void;
}

/** @internal */
interface CustomMessageSender {
    sendMessage(message: string, data: string | undefined): void;
}

interface CustomMessageHandlerProps {
    /**
     * A function that will be called when the Player UI sends a synchronous message to the integration.
     */
    onReceivedSynchronousMessage: (message: string, data: string | undefined) => string | undefined;
    /**
     * A function that will be called when the Player UI sends an asynchronous message to the integration.
     */
    onReceivedAsynchronousMessage: (message: string, data: string | undefined) => void;
}
/**
 * Android and iOS only.
 * For Android it requires Player SDK version 3.39.0 or higher.
 *
 * Provides a two-way communication channel between the Player UI and the integration.
 */
declare class CustomMessageHandler {
    private readonly onReceivedSynchronousMessage;
    private readonly onReceivedAsynchronousMessage;
    /** @internal */
    customMessageSender?: CustomMessageSender;
    /**
     * Android and iOS only.
     *
     * Creates a new `CustomMessageHandler` instance to handle two-way communication between the integation and the Player UI.
     *
     * @param options - Configuration options for the `CustomMessageHandler` instance.
     */
    constructor({ onReceivedSynchronousMessage, onReceivedAsynchronousMessage, }: CustomMessageHandlerProps);
    /**
     * Gets called when a synchronous message was received from the Bitmovin Web UI.
     *
     * @param message Identifier of the message.
     * @param data Optional data of the message as string (can be a serialized object).
     * @returns Optional return value as string which will be propagates back to the JS counterpart.
     */
    receivedSynchronousMessage(message: string, data: string | undefined): string | undefined;
    /**
     * Gets called when an asynchronous message was received from the Bitmovin Web UI.
     *
     * @param message Identifier of the message.
     * @param data Optional data of the message as string (can be a serialized object).
     */
    receivedAsynchronousMessage(message: string, data: string | undefined): void;
    /**
     * Android and iOS only.
     *
     * Sends a message to the Player UI.
     *
     * @param message - Identifier for the callback which should be called.
     * @param data - Payload for the callback.
     */
    sendMessage(message: string, data: string | undefined): void;
}

/**
 * Provides options to configure Picture in Picture playback.
 */
interface PictureInPictureConfig {
    /**
     * Whether Picture in Picture feature is enabled or not.
     *
     * Default is `false`.
     */
    isEnabled?: boolean;
    /**
     * Defines whether Picture in Picture should start automatically when the app transitions to background.
     *
     * Does not have any affect when Picture in Picture is disabled.
     *
     * Default is `false`.
     *
     * @platform iOS 14.2 and above
     */
    shouldEnterOnBackground?: boolean;
}

/**
 * Configures the visual presentation and behaviour of the `PlayerView`.
 */
interface PlayerViewConfig {
    /**
     * Configures the visual presentation and behaviour of the Bitmovin Player UI.
     * A {@link WebUiConfig} can be used to configure the default Bitmovin Player Web UI.
     *
     * Default is {@link WebUiConfig}.
     *
     * Limitations:
     * Configuring the `uiConfig` only has an effect if the {@link StyleConfig.userInterfaceType} is set to {@link UserInterfaceType.Bitmovin}.
     */
    uiConfig?: UiConfig;
    /**
     * Provides options to configure Picture in Picture playback.
     */
    pictureInPictureConfig?: PictureInPictureConfig;
    /**
     * When set to `true`, the first frame of the main content will not be rendered before playback starts. Default is `false`.
     * This configuration has no effect for the {@link UserInterfaceType.Subtitle} on iOS/tvOS.
     *
     * To reliably hide the first frame before a pre-roll ad, please ensure that you are using the {@link AdvertisingConfig} to schedule ads and not the {@link Player.scheduleAd} API call.
     */
    hideFirstFrame?: boolean;
}
/**
 * Configures the visual presentation and behaviour of the Bitmovin Player UI.
 */
interface UiConfig {
}
/**
 * Configures the visual presentation and behaviour of the Bitmovin Web UI.
 */
interface WebUiConfig extends UiConfig {
    /**
     * Whether the Bitmovin Web UI will show playback speed selection options in the settings menu.
     * Default is `true`.
     */
    playbackSpeedSelectionEnabled?: boolean;
}

/**
 * Base `PlayerView` component props.
 * Used to establish common props between `NativePlayerView` and {@link PlayerView}.
 */
interface BasePlayerViewProps {
    /**
     * The {@link FullscreenHandler} that is used by the {@link PlayerView} to control the fullscreen mode.
     */
    fullscreenHandler?: FullscreenHandler;
    /**
     * The {@link CustomMessageHandler} that can be used to directly communicate with the embedded Bitmovin Web UI.
     */
    customMessageHandler?: CustomMessageHandler;
    /**
     * Style of the {@link PlayerView}.
     */
    style?: ViewStyle;
    /**
     * Configures the visual presentation and behaviour of the {@link PlayerView}.
     * The value must not be altered after setting it initially.
     */
    config?: PlayerViewConfig;
}
/**
 * {@link PlayerView} component props.
 */
interface PlayerViewProps extends BasePlayerViewProps, PlayerViewEvents {
    viewRef?: React.MutableRefObject<null>;
    /**
     * {@link Player} instance (generally returned from {@link usePlayer} hook) that will control
     * and render audio/video inside the {@link PlayerView}.
     */
    player: Player;
    /**
     * Can be set to `true` to request fullscreen mode, or `false` to request exit of fullscreen mode.
     * Should not be used to get the current fullscreen state. Use {@link PlayerViewEvents.onFullscreenEnter} and {@link PlayerViewEvents.onFullscreenExit}
     * or the {@link FullscreenHandler.isFullscreenActive} property to get the current state.
     * Using this property to change the fullscreen state, it is ensured that the embedded Player UI is also aware
     * of potential fullscreen state changes.
     * To use this property, a {@link FullscreenHandler} must be set.
     */
    isFullscreenRequested?: Boolean;
    /**
     * A value defining how the video is displayed within the parent container's bounds.
     * Possible values are defined in {@link ScalingMode}.
     */
    scalingMode?: ScalingMode;
    /**
     * Can be set to `true` to request Picture in Picture mode, or `false` to request exit of Picture in Picture mode.
     * Should not be used to get the current Picture in Picture state. Use {@link PlayerViewEvents.onPictureInPictureEnter} and {@link PlayerViewEvents.onPictureInPictureExit}.
     */
    isPictureInPictureRequested?: Boolean;
}

/**
 * Component that provides the Bitmovin Player UI and default UI handling to an attached `Player` instance.
 * This component needs a `Player` instance to work properly so make sure one is passed to it as a prop.
 *
 * @param options configuration options
 */
declare function PlayerView({ viewRef, style, player, config, fullscreenHandler, customMessageHandler, isFullscreenRequested, scalingMode, isPictureInPictureRequested, ...props }: PlayerViewProps): React$1.JSX.Element;

/**
 * React hook that creates and returns a reference to a `Player` instance
 * that can be used inside any component.
 */
declare function usePlayer(config?: PlayerConfig): Player;

/**
 * The options to be used for initializing `BitmovinCastManager`
 * @platform Android, iOS
 */
interface BitmovinCastManagerOptions {
    /**
     * ID of receiver application.
     * Using `null` value will result in using the default application ID
     */
    applicationId?: string | null;
    /**
     * A custom message namespace to be used for communication between sender and receiver.
     * Using `null` value will result in using the default message namespace
     */
    messageNamespace?: string | null;
}
/**
 * Singleton providing access to GoogleCast related features.
 * The `BitmovinCastManager` needs to be initialized by calling `BitmovinCastManager.initialize`
 * before `Player` creation to enable casting features.
 *
 * @platform Android, iOS
 */
declare const BitmovinCastManager: {
    /**
     * Returns whether the `BitmovinCastManager` is initialized.
     * @returns A promise that resolves with a boolean indicating whether the `BitmovinCastManager` is initialized
     */
    isInitialized: () => Promise<boolean>;
    /**
     * Initialize `BitmovinCastManager` based on the provided `BitmovinCastManagerOptions`.
     * This method needs to be called before `Player` creation to enable casting features.
     * If no options are provided, the default options will be used.
     *
     * IMPORTANT: This should only be called when the Google Cast SDK is available in the application.
     *
     * @param options The options to be used for initializing `BitmovinCastManager`
     * @returns A promise that resolves when the `BitmovinCastManager` was initialized successfully
     */
    initialize: (options?: BitmovinCastManagerOptions | null) => Promise<void>;
    /**
     * Must be called in every Android Activity to update the context to the current one.
     * Make sure to call this method on every Android Activity switch.
     *
     * @returns A promise that resolves when the context was updated successfully
     * @platform Android
     */
    updateContext: () => Promise<void>;
    /**
     * Sends the given message to the cast receiver.
     *
     * @param message The message to be sent
     * @param messageNamespace The message namespace to be used, in case of null the default message namespace will be used
     * @returns A promise that resolves when the message was sent successfully
     */
    sendMessage: (message: String, messageNamespace?: String | null) => any;
};

/**
 * Represents a native Network configuration object.
 * @internal
 */
declare class Network extends NativeInstance<NetworkConfig> {
    /**
     * Whether this object's native instance has been created.
     */
    isInitialized: boolean;
    /**
     * Whether this object's native instance has been disposed.
     */
    isDestroyed: boolean;
    /**
     * Allocates the Network config instance and its resources natively.
     */
    initialize: () => void;
    /**
     * Destroys the native Network config and releases all of its allocated resources.
     */
    destroy: () => void;
    /**
     * Applies the user-defined `preprocessHttpRequest` function to native's `type` and `request` data and store
     * the result back in `NetworkModule`.
     *
     * Called from native code when `NetworkConfig.preprocessHttpRequest` is dispatched.
     *
     * @param requestId Passed through to identify the completion handler of the request on native.
     * @param type Type of the request to be made.
     * @param request The HTTP request to process.
     */
    onPreprocessHttpRequest: (requestId: string, type: HttpRequestType, request: HttpRequest) => void;
    /**
     * Applies the user-defined `preprocessHttpResponse` function to native's `type` and `response` data and store
     * the result back in `NetworkModule`.
     *
     * Called from native code when `NetworkConfig.preprocessHttpResponse` is dispatched.
     *
     * @param responseId Passed through to identify the completion handler of the response on native.
     * @param type Type of the request to be made.
     * @param response The HTTP response to process.
     */
    onPreprocessHttpResponse: (responseId: string, type: HttpRequestType, response: HttpResponse) => void;
}

export { Ad, AdBreak, AdBreakFinishedEvent, AdBreakStartedEvent, AdClickedEvent, AdConfig, AdData, AdErrorEvent, AdFinishedEvent, AdItem, AdManifestLoadEvent, AdManifestLoadedEvent, AdQuartile, AdQuartileEvent, AdScheduledEvent, AdSkippedEvent, AdSource, AdSourceType, AdStartedEvent, AdaptationConfig, AdvertisingConfig, AnalyticsApi, AnalyticsConfig, AudioAddedEvent, AudioChangedEvent, AudioRemovedEvent, AudioSession, AudioSessionCategory, AudioTrack, BasePlayerViewProps, BitmovinCastManager, BitmovinCastManagerOptions, BitmovinNativeOfflineEventData, BufferApi, BufferConfig, BufferLevel, BufferLevels, BufferMediaTypeConfig, BufferType, CastAvailableEvent, CastPausedEvent, CastPayload, CastPlaybackFinishedEvent, CastPlayingEvent, CastStartEvent, CastStartedEvent, CastStoppedEvent, CastTimeUpdatedEvent, CastWaitingForDeviceEvent, CueEnterEvent, CueExitEvent, CustomDataConfig, CustomMessageHandler, CustomMessageHandlerProps, DefaultMetadata, DestroyEvent, DownloadFinishedEvent, Drm, DrmConfig, ErrorEvent, Event, EventSource, FairplayConfig, FullscreenDisabledEvent, FullscreenEnabledEvent, FullscreenEnterEvent, FullscreenExitEvent, FullscreenHandler, HttpRequest, HttpRequestType, HttpResponse, LiveConfig, LoadingState, MediaType, MutedEvent, Network, NetworkConfig, OfflineContentConfig, OfflineContentManager, OfflineContentManagerListener, OfflineContentOptionEntry, OfflineContentOptions, OfflineDownloadRequest, OfflineEvent, OfflineEventType, OfflineSourceOptions, OfflineState, OnCanceledEvent, OnCompletedEvent, OnDrmLicenseExpiredEvent, OnDrmLicenseUpdatedEvent, OnErrorEvent, OnOptionsAvailableEvent, OnProgressEvent, OnResumedEvent, OnSuspendedEvent, PausedEvent, PictureInPictureAvailabilityChangedEvent, PictureInPictureConfig, PictureInPictureEnterEvent, PictureInPictureEnteredEvent, PictureInPictureExitEvent, PictureInPictureExitedEvent, PlayEvent, PlaybackConfig, PlaybackFinishedEvent, PlaybackSpeedChangedEvent, Player, PlayerActiveEvent, PlayerConfig, PlayerErrorEvent, PlayerView, PlayerViewConfig, PlayerViewProps, PlayerWarningEvent, PlayingEvent, ReadyEvent, RemoteControlConfig, ScalingMode, SeekEvent, SeekPosition, SeekedEvent, SideLoadedSubtitleTrack, Source, SourceConfig, SourceErrorEvent, SourceLoadEvent, SourceLoadedEvent, SourceMetadata, SourceOptions, SourceRemoteControlConfig, SourceType, SourceUnloadedEvent, SourceWarningEvent, StallEndedEvent, StallStartedEvent, StyleConfig, SubtitleAddedEvent, SubtitleChangedEvent, SubtitleFormat, SubtitleRemovedEvent, SubtitleTrack, Thumbnail, TimeChangedEvent, TimeShiftEvent, TimeShiftedEvent, TimelineReferencePoint, TweaksConfig, UiConfig, UnmutedEvent, UserInterfaceType, VideoDownloadQualityChangedEvent, VideoPlaybackQualityChangedEvent, VideoQuality, WebUiConfig, WidevineConfig, usePlayer };
